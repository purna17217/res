


import com.microfocus.cobol.runtimeservices.RunUnit;
public class MobileEnqService {
	
	Logger logger = LoggerFactory.getLogger(MobileEnqService.class);
	Connection connection;
	String errno = new String();
	String customerStatus = CacheConfig.frameworkConfigProperties.getProperty(FrameworkConstants.LOOKUP_FILES_PATH);
	Properties custStatus = PropertyLoader
			.readPropertyFile(new String(customerStatus + "/CustomerStatus.properties"));
	
	public List<String> callMOBEnquiryChild( String refno,String branchno, String tellerno, String mobno, String cifno, int requestedNumberOfRecords,DataSource dataSource,String commonArea) throws InterruptedException, ExecutionException {
		
		logger.info("VC------------------------MOB Enquiry Child Service Started With ForkJoinPool------------------------VC "+refno);

		String lacctno = cifno == null ? "00000000000000000" : String.format("%017d", new BigInteger(cifno));
		
        int numberOfRecordsToFetch = requestedNumberOfRecords > 0 ? requestedNumberOfRecords : 60;

        List<CompletableFuture<ResponseData>> futures = new ArrayList<>();

        ForkJoinPool customThreadPool = new ForkJoinPool(25);
        
    	StringBuffer allRecordsBuilder = new StringBuffer();
   	    String tempFlag = "";
        int fetchedRecordsCount = 0;
        RunUnit run1 = new RunUnit();
        try (Connection connection = dataSource.getConnection()){
        while (fetchedRecordsCount < numberOfRecordsToFetch) {
            final String currentLacctno = lacctno;
           
            CompletableFuture<ResponseData> future = CompletableFuture.supplyAsync(() -> {
            	JVMMOB jvmmob = new JVMMOB();
            	LsBranchNo  	mobinput1	= new LsBranchNo();
            	LsTellerNo	    mobinput2	= new LsTellerNo();
                LsMobNumber 	mobinput3 	= new LsMobNumber();
                LsCustomerNo    mobinput4	= new LsCustomerNo();
                LsFunction	    mobinput5	= new LsFunction();
				
                LsPanNumber     mobinput6   = new LsPanNumber();
                LsEmail         mobinput7   = new LsEmail();
                LsRecordArea    mobinput8   = new LsRecordArea();
                LsDataOut 	    moboutput1 	= new LsDataOut();
                LsErrorMsgNo    moboutput2 	= new LsErrorMsgNo();
                LsLastCust      moboutput3 	= new LsLastCust();
                LsLastNumCuid	mobcuid		= new LsLastNumCuid();
                mobinput2.setLsTellerNo(tellerno);
                mobinput1.setLsBranchNo(String.format("%016d", Integer.parseInt(branchno)));  
                mobinput3.setLsMobNumber(mobno);
                mobinput4.setLsCustomerNo(currentLacctno);
                mobinput5.setLsFunction("M");
                mobinput6.setLsPanNumber("");
                mobinput7.setLsEmail("");
                mobcuid.setLsLastNumCuid("");
                mobinput8.setLsRecordArea(commonArea);
           
                run1.Add(jvmmob);
                
             // Call the JVMAVBL service
                run1.Call("JVMMOB", mobinput1.get_Reference(), mobinput2.get_Reference(), mobinput3.get_Reference(),mobinput6.get_Reference(),mobinput7.get_Reference(), mobinput4.get_Reference(),mobinput5.get_Reference(), moboutput1.get_Reference(), moboutput2.get_Reference(), moboutput3.get_Reference(),mobcuid.get_Reference(), mobinput8.get_Reference(),connection );
                
                ResponseData responseData  = new ResponseData();
                responseData.outResponse   = moboutput1.getLsDataOut();
                responseData.errno         = moboutput2.getLsErrorMsgNo();
                responseData.lacctno       = moboutput3.getLsLastCust();
                return responseData;
            }, customThreadPool);

            futures.add(future);
            
            ResponseData lastResult = futures.get(futures.size() - 1).get();

            if (lastResult.outResponse == null || lastResult.outResponse.trim().isEmpty()) {
               logger.error("No outResponse from JVMMOB. Terminating process.");
              
                break;
            }
           
            lacctno = lastResult.lacctno;

            String outResponse = lastResult.outResponse;
            int startIndex = 0;
            int endIndex = 0;
            while (startIndex + 83 <= outResponse.length() && fetchedRecordsCount < numberOfRecordsToFetch) {
                endIndex = startIndex + 83;
                String tempBreak = outResponse.substring(startIndex, endIndex);
                if(tempBreak==null||tempBreak.trim().isEmpty())
                {
                	break;
                }
                String lastThree = tempBreak.substring(77,80);
                String custDesc = custStatus.getProperty(lastThree);
                custDesc = (custDesc==null) ? " ".repeat(100) : custDesc;
                allRecordsBuilder.append(outResponse.substring(startIndex, endIndex)+custDesc);
                startIndex = endIndex;
                fetchedRecordsCount++;
            }
        }
        run1.close();
        tempFlag = "Y";
        
        logger.info("VC------------------------Mobile Enquiry Service no of records fetched : " +fetchedRecordsCount+" ------------------------VC " + refno);
    } 
        
        catch (SQLException e)
        {
        	errno = "3293";
        	tempFlag = "N";
        } 

        List<String> res = new ArrayList<>();
        res.add(allRecordsBuilder.toString()); 
        res.add(String.valueOf(fetchedRecordsCount)); 
        if("Y".equals(tempFlag))
        {
        	if(allRecordsBuilder.length()==0)
        	{
        		res.add(futures.get(futures.size() - 1).get().errno); 
        	}
        	else
        	{
        		res.add("0000");
        	}
        }
        else
        {
        	res.add(errno);
        }

        logger.info("VC------------------------MOB Enquiry Child Service Ended With ForkJoinPool------------------------VC "+refno);

        customThreadPool.shutdown();
		
        return res;
        
        
    }
		    private class ResponseData {
		        String outResponse;
		        String errno;
		        String lacctno;
		      
	    }
}



=============================================================================================================================================================================================================================================



public class MobileEnqService {
	
	Logger logger = LoggerFactory.getLogger(MobileEnqService.class);
	Connection connection;
	String errno = new String();
	String customerStatus = CacheConfig.frameworkConfigProperties.getProperty(FrameworkConstants.LOOKUP_FILES_PATH);
	Properties custStatus = PropertyLoader
			.readPropertyFile(new String(customerStatus + "/CustomerStatus.properties"));
	
	public List<String> callMOBEnquiryChild( String refno,String branchno, String tellerno, String mobno, String cifno, int requestedNumberOfRecords,DataSource dataSource,String commonArea) throws InterruptedException, ExecutionException {
		
		logger.info("VC------------------------MOB Enquiry Child Service Started WithOut ForkJoinPool------------------------VC "+refno);

		String lacctno = cifno == null ? "00000000000000000" : String.format("%017d", new BigInteger(cifno));
		
        int numberOfRecordsToFetch = requestedNumberOfRecords > 0 ? requestedNumberOfRecords : 60;       
        int index = 0;       
        StringBuilder allRecordsBuilder = new StringBuilder();
   	    String tempFlag = "";
        try (Connection connection = dataSource.getConnection())
        {
        	
        	/* ===================== DB CONNECTION ACQUIRED ===================== */
            logger.info(
                    "DB-CONN-ACQUIRED | Ref={} | Thread={} | ConnHash={}",
                    refno,
                    Thread.currentThread().getName(),
                    System.identityHashCode(connection)
            );
                	
            
        	  	JVMMOB jvmmob = new JVMMOB();
            	LsBranchNo  	mobinput1	= new LsBranchNo();
            	LsTellerNo	    mobinput2	= new LsTellerNo();
                LsMobNumber 	mobinput3 	= new LsMobNumber();
                LsCustomerNo    mobinput4	= new LsCustomerNo();
                LsFunction	    mobinput5	= new LsFunction();
				
                LsPanNumber     mobinput6   = new LsPanNumber();
                LsEmail         mobinput7   = new LsEmail();
                LsRecordArea    mobinput8   = new LsRecordArea();
                LsDataOut 	    moboutput1 	= new LsDataOut();
                LsErrorMsgNo    moboutput2 	= new LsErrorMsgNo();
                LsLastCust      moboutput3 	= new LsLastCust();
                LsLastNumCuid	mobcuid		= new LsLastNumCuid();
                mobinput2.setLsTellerNo(tellerno);
                mobinput1.setLsBranchNo(String.format("%016d", Integer.parseInt(branchno)));  
                mobinput3.setLsMobNumber(mobno);
                mobinput4.setLsCustomerNo(lacctno);
                mobinput5.setLsFunction("M");
                mobinput6.setLsPanNumber("");
                mobinput7.setLsEmail("");
                mobcuid.setLsLastNumCuid("");
                mobinput8.setLsRecordArea(commonArea);
                
               
                
                try (RunUnit run1 = new RunUnit())
                {
                run1.Add(jvmmob);
                
                /* ===================== COBOL START ===================== */
                long start = System.currentTimeMillis();
                logger.info(
                        "COBOL-START | Ref={} | AsyncThread={} | ConnHash={}",
                        refno,
                        Thread.currentThread().getName(),
                        System.identityHashCode(connection)
                );
                
             // Call the JVMAVBL service
                run1.Call("JVMMOB", mobinput1.get_Reference(), mobinput2.get_Reference(), mobinput3.get_Reference(),mobinput6.get_Reference(),mobinput7.get_Reference(), mobinput4.get_Reference(),mobinput5.get_Reference(), moboutput1.get_Reference(), moboutput2.get_Reference(), moboutput3.get_Reference(),mobcuid.get_Reference(), mobinput8.get_Reference(),connection );
                /* ===================== COBOL END ===================== */
                logger.info(
                        "COBOL-END | Ref={} | AsyncThread={} | ConnHash={} | TimeMs={}",
                        refno,
                        Thread.currentThread().getName(),
                        System.identityHashCode(connection),
                        System.currentTimeMillis() - start
                );
         
		} 
                catch (Exception e) 
        {
			logger.info("Error in using RunUnit");
		}
          
            
                
              if(numberOfRecordsToFetch!=0)
              {
            	  while (index < numberOfRecordsToFetch) {
                      
                      String outPutRes = moboutput1.getLsDataOutArray(index);
                      if(outPutRes==null||outPutRes.trim().isEmpty())
                      {
                      	break;
                      }
                      String lastThree = outPutRes.substring(77,80);
                      String custDesc = custStatus.getProperty(lastThree);
                      custDesc = (custDesc==null) ? " ".repeat(100) : custDesc;
                      allRecordsBuilder.append(outPutRes.substring(0, 83)+custDesc);
                      index++;
                  }
              }
              
               
            
        
       
        tempFlag = "Y";
        
        logger.info("VC------------------------Mobile Enquiry Service no of records fetched : " +index+" ------------------------VC " + refno);
    } 
        
        catch (SQLException e)
        {
        	errno = "3293";
        	tempFlag = "N";
        } 

        List<String> res = new ArrayList<>();
        res.add(allRecordsBuilder.toString()); 
        res.add(String.valueOf(index)); 
        if("Y".equals(tempFlag))
        {
        		res.add("0000");
        }
        else
        {
        	res.add(errno);
        }

        logger.info("VC------------------------MOB Enquiry Child Service Ended WithOut ForkJoinPool------------------------VC "+refno);

		
        return res;
        
        
    }
}
































=====================================================================================================================================================================================
public class MobileEnqService {

    Logger logger = LoggerFactory.getLogger(MobileEnqService.class);

    String errno = new String();
    String customerStatus =
            CacheConfig.frameworkConfigProperties.getProperty(FrameworkConstants.LOOKUP_FILES_PATH);

    Properties custStatus = PropertyLoader
            .readPropertyFile(customerStatus + "/CustomerStatus.properties");

    public List<String> callMOBEnquiryChild(
            String refno,
            String branchno,
            String tellerno,
            String mobno,
            String cifno,
            int requestedNumberOfRecords,
            DataSource dataSource,
            String commonArea
    ) throws InterruptedException, ExecutionException {

        logger.info("VC------------------------MOB Enquiry Child Service Started------------------------VC {}", refno);

        String lacctno = cifno == null
                ? "00000000000000000"
                : String.format("%017d", new BigInteger(cifno));

        int numberOfRecordsToFetch = requestedNumberOfRecords > 0 ? requestedNumberOfRecords : 60;

        List<CompletableFuture<ResponseData>> futures = new ArrayList<>();
        ForkJoinPool customThreadPool = new ForkJoinPool(25);

        StringBuffer allRecordsBuilder = new StringBuffer();
        String tempFlag = "";
        int fetchedRecordsCount = 0;

        RunUnit run1 = new RunUnit();

        try (Connection connection = dataSource.getConnection()) {

            /* ===================== DB CONNECTION ACQUIRED ===================== */
            logger.info(
                    "DB-CONN-ACQUIRED | Ref={} | Thread={} | ConnHash={}",
                    refno,
                    Thread.currentThread().getName(),
                    System.identityHashCode(connection)
            );

            while (fetchedRecordsCount < numberOfRecordsToFetch) {

                logger.info(
                        "ASYNC-SUBMIT | Ref={} | Thread={} | lacctno={}",
                        refno,
                        Thread.currentThread().getName(),
                        lacctno
                );

                final String currentLacctno = lacctno;

                CompletableFuture<ResponseData> future =
                        CompletableFuture.supplyAsync(() -> {

                            JVMMOB jvmmob = new JVMMOB();

                            LsBranchNo mobinput1 = new LsBranchNo();
                            LsTellerNo mobinput2 = new LsTellerNo();
                            LsMobNumber mobinput3 = new LsMobNumber();
                            LsCustomerNo mobinput4 = new LsCustomerNo();
                            LsFunction mobinput5 = new LsFunction();
                            LsPanNumber mobinput6 = new LsPanNumber();
                            LsEmail mobinput7 = new LsEmail();
                            LsRecordArea mobinput8 = new LsRecordArea();

                            LsDataOut moboutput1 = new LsDataOut();
                            LsErrorMsgNo moboutput2 = new LsErrorMsgNo();
                            LsLastCust moboutput3 = new LsLastCust();
                            LsLastNumCuid mobcuid = new LsLastNumCuid();

                            mobinput1.setLsBranchNo(String.format("%016d", Integer.parseInt(branchno)));
                            mobinput2.setLsTellerNo(tellerno);
                            mobinput3.setLsMobNumber(mobno);
                            mobinput4.setLsCustomerNo(currentLacctno);
                            mobinput5.setLsFunction("M");
                            mobinput6.setLsPanNumber("");
                            mobinput7.setLsEmail("");
                            mobcuid.setLsLastNumCuid("");
                            mobinput8.setLsRecordArea(commonArea);

                            run1.Add(jvmmob);

                            /* ===================== COBOL START ===================== */
                            long start = System.currentTimeMillis();
                            logger.info(
                                    "COBOL-START | Ref={} | AsyncThread={} | ConnHash={}",
                                    refno,
                                    Thread.currentThread().getName(),
                                    System.identityHashCode(connection)
                            );

                            run1.Call(
                                    "JVMMOB",
                                    mobinput1.get_Reference(),
                                    mobinput2.get_Reference(),
                                    mobinput3.get_Reference(),
                                    mobinput6.get_Reference(),
                                    mobinput7.get_Reference(),
                                    mobinput4.get_Reference(),
                                    mobinput5.get_Reference(),
                                    moboutput1.get_Reference(),
                                    moboutput2.get_Reference(),
                                    moboutput3.get_Reference(),
                                    mobcuid.get_Reference(),
                                    mobinput8.get_Reference(),
                                    connection
                            );

                            /* ===================== COBOL END ===================== */
                            logger.info(
                                    "COBOL-END | Ref={} | AsyncThread={} | ConnHash={} | TimeMs={}",
                                    refno,
                                    Thread.currentThread().getName(),
                                    System.identityHashCode(connection),
                                    System.currentTimeMillis() - start
                            );

                            ResponseData responseData = new ResponseData();
                            responseData.outResponse = moboutput1.getLsDataOut();
                            responseData.errno = moboutput2.getLsErrorMsgNo();
                            responseData.lacctno = moboutput3.getLsLastCust();

                            return responseData;

                        }, customThreadPool);

                futures.add(future);

                /* ===================== BLOCKING POINT ===================== */
                ResponseData lastResult = future.get();

                logger.info(
                        "FUTURE-COMPLETED | Ref={} | Thread={} | fetchedRecords={}",
                        refno,
                        Thread.currentThread().getName(),
                        fetchedRecordsCount
                );

                if (lastResult.outResponse == null || lastResult.outResponse.trim().isEmpty()) {
                    logger.error("No outResponse from JVMMOB. Terminating process. Ref={}", refno);
                    break;
                }

                lacctno = lastResult.lacctno;

                String outResponse = lastResult.outResponse;
                int startIndex = 0;

                while (startIndex + 83 <= outResponse.length()
                        && fetchedRecordsCount < numberOfRecordsToFetch) {

                    String tempBreak = outResponse.substring(startIndex, startIndex + 83);
                    if (tempBreak.trim().isEmpty()) {
                        break;
                    }

                    String lastThree = tempBreak.substring(77, 80);
                    String custDesc = custStatus.getProperty(lastThree);
                    custDesc = (custDesc == null) ? " ".repeat(100) : custDesc;

                    allRecordsBuilder.append(tempBreak).append(custDesc);
                    startIndex += 83;
                    fetchedRecordsCount++;
                }
            }

            logger.info(
                    "DB-CONN-RELEASE | Ref={} | Thread={} | ConnHash={}",
                    refno,
                    Thread.currentThread().getName(),
                    System.identityHashCode(connection)
            );

            run1.close();
            tempFlag = "Y";

            logger.info(
                    "VC------------------------Mobile Enquiry Records Fetched={}------------------------VC {}",
                    fetchedRecordsCount,
                    refno
            );

        } catch (SQLException e) {
            logger.error("SQL-ERROR | Ref={}", refno, e);
            errno = "3293";
            tempFlag = "N";
        }

        List<String> res = new ArrayList<>();
        res.add(allRecordsBuilder.toString());
        res.add(String.valueOf(fetchedRecordsCount));

        if ("Y".equals(tempFlag)) {
            if (allRecordsBuilder.length() == 0 && !futures.isEmpty()) {
                res.add(futures.get(futures.size() - 1).get().errno);
            } else {
                res.add("0000");
            }
        } else {
            res.add(errno);
        }

        logger.info("VC------------------------MOB Enquiry Child Service Ended------------------------VC {}", refno);

        customThreadPool.shutdown();
        return res;
    }

    private class ResponseData {
        String outResponse;
        String errno;
        String lacctno;
    }
}















//           SBI Core Banking Project, Hyderabad, India.          *
//*****************************************************************
//                                                                *
//  	           PROGRAM - PFMOBEnquiryService.Java                 
//                                                                *
//*****************************************************************
//                 P R O G R A M    H I S T O R Y                 *
//                                                                *
//   PROGRAMMER    :    DATE       :  SPR NO   :   COMMENTS       *
//----------------------------------------------------------------*
//Niharika Tammana : 15/10/2024    : 24090001  :  MICROSERVICES   *
//Naga Sai Ganesh  : 15/10/2024    : 24090001  :  MICROSERVICES   *
//Niharika Tammana : 24/01/2025    : 25010222  :  MICROSERVICES   *
//Purna Tirunagari: 01/10/2025    : 25100006  :  MICROSERVICES   *
//----------------------------------------------------------------*
//START OF IR 25100006
package com.tcs.bancs.microservices.services;

import java.math.BigInteger;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;
import java.util.concurrent.*;
import javax.sql.DataSource;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.microfocus.cobol.runtimeservices.RunUnit;
import com.tcs.bancs.microservices.config.CacheConfig;
import com.tcs.bancs.microservices.configuration.PropertyLoader;
import com.tcs.bancs.microservices.jvm.scpf.JVMMOB;
import com.tcs.bancs.microservices.jvm.scpf.JVMMOB.LsBranchNo;
import com.tcs.bancs.microservices.jvm.scpf.JVMMOB.LsCustomerNo;
import com.tcs.bancs.microservices.jvm.scpf.JVMMOB.LsDataOut;
import com.tcs.bancs.microservices.jvm.scpf.JVMMOB.LsEmail;
import com.tcs.bancs.microservices.jvm.scpf.JVMMOB.LsErrorMsgNo;
import com.tcs.bancs.microservices.jvm.scpf.JVMMOB.LsFunction;
import com.tcs.bancs.microservices.jvm.scpf.JVMMOB.LsLastCust;
import com.tcs.bancs.microservices.jvm.scpf.JVMMOB.LsLastNumCuid;
import com.tcs.bancs.microservices.jvm.scpf.JVMMOB.LsMobNumber;
import com.tcs.bancs.microservices.jvm.scpf.JVMMOB.LsPanNumber;
import com.tcs.bancs.microservices.jvm.scpf.JVMMOB.LsRecordArea;
import com.tcs.bancs.microservices.jvm.scpf.JVMMOB.LsTellerNo;
import com.tcs.bancs.microservices.util.FrameworkConstants;

public class MobileEnqService {
	
	Logger logger = LoggerFactory.getLogger(MobileEnqService.class);
	Connection connection;
	String errno = new String();
	String customerStatus = CacheConfig.frameworkConfigProperties.getProperty(FrameworkConstants.LOOKUP_FILES_PATH);
	Properties custStatus = PropertyLoader
			.readPropertyFile(new String(customerStatus + "/CustomerStatus.properties"));
	
	public List<String> callMOBEnquiryChild( String refno,String branchno, String tellerno, String mobno, String cifno, int requestedNumberOfRecords,DataSource dataSource,String commonArea) throws InterruptedException, ExecutionException {
		
		logger.info("VC------------------------MOB Enquiry Child Service Started------------------------VC "+refno);

		String lacctno = cifno == null ? "00000000000000000" : String.format("%017d", new BigInteger(cifno));
		
        int numberOfRecordsToFetch = requestedNumberOfRecords > 0 ? requestedNumberOfRecords : 60;

        List<CompletableFuture<ResponseData>> futures = new ArrayList<>();

        ForkJoinPool customThreadPool = new ForkJoinPool(25);
        
    	StringBuffer allRecordsBuilder = new StringBuffer();
   	    String tempFlag = "";
        int fetchedRecordsCount = 0;
        RunUnit run1 = new RunUnit();
        try (Connection connection = dataSource.getConnection()){
        while (fetchedRecordsCount < numberOfRecordsToFetch) {
            final String currentLacctno = lacctno;
           
            CompletableFuture<ResponseData> future = CompletableFuture.supplyAsync(() -> {
            	JVMMOB jvmmob = new JVMMOB();
            	LsBranchNo  	mobinput1	= new LsBranchNo();
            	LsTellerNo	    mobinput2	= new LsTellerNo();
                LsMobNumber 	mobinput3 	= new LsMobNumber();
                LsCustomerNo    mobinput4	= new LsCustomerNo();
                LsFunction	    mobinput5	= new LsFunction();
				
                LsPanNumber     mobinput6   = new LsPanNumber();
                LsEmail         mobinput7   = new LsEmail();
                LsRecordArea    mobinput8   = new LsRecordArea();
                LsDataOut 	    moboutput1 	= new LsDataOut();
                LsErrorMsgNo    moboutput2 	= new LsErrorMsgNo();
                LsLastCust      moboutput3 	= new LsLastCust();
                LsLastNumCuid	mobcuid		= new LsLastNumCuid();
                mobinput2.setLsTellerNo(tellerno);
                mobinput1.setLsBranchNo(String.format("%016d", Integer.parseInt(branchno)));  
                mobinput3.setLsMobNumber(mobno);
                mobinput4.setLsCustomerNo(currentLacctno);
                mobinput5.setLsFunction("M");
                mobinput6.setLsPanNumber("");
                mobinput7.setLsEmail("");
                mobcuid.setLsLastNumCuid("");
                mobinput8.setLsRecordArea(commonArea);
           
                run1.Add(jvmmob);
                
             // Call the JVMAVBL service
                run1.Call("JVMMOB", mobinput1.get_Reference(), mobinput2.get_Reference(), mobinput3.get_Reference(),mobinput6.get_Reference(),mobinput7.get_Reference(), mobinput4.get_Reference(),mobinput5.get_Reference(), moboutput1.get_Reference(), moboutput2.get_Reference(), moboutput3.get_Reference(),mobcuid.get_Reference(), mobinput8.get_Reference(),connection );
                
                ResponseData responseData  = new ResponseData();
                responseData.outResponse   = moboutput1.getLsDataOut();
                responseData.errno         = moboutput2.getLsErrorMsgNo();
                responseData.lacctno       = moboutput3.getLsLastCust();
                return responseData;
            }, customThreadPool);

            futures.add(future);
            
            ResponseData lastResult = futures.get(futures.size() - 1).get();

            if (lastResult.outResponse == null || lastResult.outResponse.trim().isEmpty()) {
               logger.error("No outResponse from JVMMOB. Terminating process.");
              
                break;
            }
           
            lacctno = lastResult.lacctno;

            String outResponse = lastResult.outResponse;
            int startIndex = 0;
            int endIndex = 0;
            while (startIndex + 83 <= outResponse.length() && fetchedRecordsCount < numberOfRecordsToFetch) {
                endIndex = startIndex + 83;
                String tempBreak = outResponse.substring(startIndex, endIndex);
                if(tempBreak==null||tempBreak.trim().isEmpty())
                {
                	break;
                }
                String lastThree = tempBreak.substring(77,80);
                String custDesc = custStatus.getProperty(lastThree);
                custDesc = (custDesc==null) ? " ".repeat(100) : custDesc;
                allRecordsBuilder.append(outResponse.substring(startIndex, endIndex)+custDesc);
                startIndex = endIndex;
                fetchedRecordsCount++;
            }
        }
        run1.close();
        tempFlag = "Y";
        
        logger.info("VC------------------------Mobile Enquiry Service no of records fetched : " +fetchedRecordsCount+" ------------------------VC " + refno);
    } 
        
        catch (SQLException e)
        {
        	errno = "3293";
        	tempFlag = "N";
        } 

        List<String> res = new ArrayList<>();
        res.add(allRecordsBuilder.toString()); 
        res.add(String.valueOf(fetchedRecordsCount)); 
        if("Y".equals(tempFlag))
        {
        	if(allRecordsBuilder.length()==0)
        	{
        		res.add(futures.get(futures.size() - 1).get().errno); 
        	}
        	else
        	{
        		res.add("0000");
        	}
        }
        else
        {
        	res.add(errno);
        }

        logger.info("VC------------------------MOB Enquiry Child Service Ended------------------------VC "+refno);

        customThreadPool.shutdown();
		
        return res;
        
        
    }
		    private class ResponseData {
		        String outResponse;
		        String errno;
		        String lacctno;
		      
	    }
}
//END OF IR 25100006

























long start = System.currentTimeMillis();
logger.info("COBOL-START | Thread={} | Conn={}",
        Thread.currentThread().getName(),
        System.identityHashCode(connection));

runUnit.Call(...);

logger.info("COBOL-END | Thread={} | Conn={} | Time={} ms",
        Thread.currentThread().getName(),
        System.identityHashCode(connection),
        System.currentTimeMillis() - start);

























//*****************************************************************
//                                                                *
//  	           PROGRAM - PRNightDBManager.Java                 
//                                                                *
//*****************************************************************
//                 P R O G R A M    H I S T O R Y                 *
//                                                                *
//   PROGRAMMER    :    DATE       :  SPR NO   :   COMMENTS       *
//----------------------------------------------------------------*
//Purna Tirunagari  : 16/12/2025    : 25120045 :  MICROSERVICES   *
//----------------------------------------------------------------*

package com.tcs.bancs.microservices.config;

import com.zaxxer.hikari.HikariDataSource;
import com.zaxxer.hikari.HikariPoolMXBean;
import com.tcs.bancs.microservices.java.validations.NOMI_Branch;
import com.zaxxer.hikari.HikariConfig;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import java.time.Duration;
import java.time.Instant;



@Component
public class PRNightDBManager {

	Logger logger = LoggerFactory.getLogger(NOMI_Branch.class);
	
	
    private final String url;
    private final String username;
    private final String password;
    private final String driver;
    private final String poolName;
    private int maxPoolSize;
    private int minPoolSize;
    private long connectionTimeout;
    private long idleTimeout;
    private long maxLifetime;
    private boolean registerMbeans;
    @Value("${prnight.datasource.fixedDelay}") 
    private Duration fixedDelayToMinimize;
    
    private volatile HikariDataSource dataSource; 

    private volatile Instant idleStartTime = null;  

    public PRNightDBManager(
    		
            @Value("${prnight.datasource.jdbc-url}") String url,
            @Value("${prnight.datasource.username}") String username,
            @Value("${prnight.datasource.password}") String password,
            @Value("${prnight.datasource.driver-class-name}") String driver,
            @Value("${prnight.datasource.hikari.pool-name}") String poolName,
            @Value("${day.datasource.hikari.maximum-pool-size}") int maxPoolSize,
            @Value("${prnight.datasource.hikari.minimum-idle}") int minPoolSize,
            @Value("${prnight.datasource.hikari.connectionTimeout}") long connectionTimeout,
            @Value("${prnight.datasource.hikari.idleTimeout}") long idleTimeout,
            @Value("${prnight.datasource.hikari.maxLifetime}") long maxLifetime,
            @Value("${prnight.datasource.hikari.registerMbeans}") boolean registerMbeans
           
    ) {
        this.url = url;
        this.username = username;
        this.password = password;
        this.driver = driver;
        this.poolName = poolName;
        this.maxPoolSize = maxPoolSize;
        this.minPoolSize = minPoolSize;
        this.connectionTimeout = connectionTimeout;
        this.idleTimeout = idleTimeout;
        this.maxLifetime = maxLifetime;
    }

    /** Lazy initialization â€” DB initializes only on first use */
    public synchronized HikariDataSource getDataSource() {
        if (dataSource == null) {
            HikariConfig config = new HikariConfig();
            config.setJdbcUrl(this.url);
            config.setUsername(this.username);
            config.setPassword(this.password);
            config.setDriverClassName(this.driver);
            config.setMaximumPoolSize(this.maxPoolSize);
            config.setMinimumIdle(this.minPoolSize);
            config.setPoolName(this.poolName);
            config.setConnectionTimeout(this.connectionTimeout);
            config.setIdleTimeout(this.idleTimeout);
            config.setMaxLifetime(this.maxLifetime);
            config.setRegisterMbeans(this.registerMbeans);
            dataSource = new HikariDataSource(config);
        }

        return dataSource;
    }


    @Scheduled(fixedDelay = 30000) // Runs every 30 seconds
    public synchronized void shutdownIfIdleForDuration() {
        if (dataSource == null || dataSource.isClosed()) {
            return;
        }

        HikariPoolMXBean poolMXBean = dataSource.getHikariPoolMXBean();
        int activeConnections = poolMXBean.getActiveConnections();
        int totalConnections = poolMXBean.getTotalConnections();

        logger.info("Monitoring DB Pool: Active Connections: {}, Total Connections: {}", activeConnections, totalConnections);

        // Check if the pool is fully idle
        if (activeConnections == 0) {
            if (idleStartTime == null) {
            
                idleStartTime = Instant.now();
                logger.info("DB pool just became fully idle. Starting {} timeout period.", fixedDelayToMinimize);
            } else {
              
                Duration currentIdleDuration = Duration.between(idleStartTime, Instant.now());
                
                if (currentIdleDuration.compareTo(fixedDelayToMinimize) >= 0) {
               
                    logger.info("DB Pool re-sizing after being idle for {}.", fixedDelayToMinimize);
                    
                    dataSource.setMinimumIdle(1);
                    dataSource.setMaximumPoolSize(2);
                    poolMXBean.softEvictConnections();

                } else {
                    logger.info("DB pool is idle, waiting for re-sizing threshold ({} elapsed).", currentIdleDuration);
                }
            }
        } else {
            if (idleStartTime != null) {
                logger.info("DB activity detected. Resetting idle shutdown timer.");
                idleStartTime = null;
                dataSource.setMaximumPoolSize(this.maxPoolSize);
                dataSource.setMinimumIdle(this.minPoolSize);
            }
        }
    }

    
    
}













private volatile boolean minimized = false;

@Scheduled(fixedDelay = 30000)
public synchronized void shutdownIfIdleForDuration() {
    if (dataSource == null || dataSource.isClosed()) {
        return;
    }

    HikariPoolMXBean poolMXBean = dataSource.getHikariPoolMXBean();
    if (poolMXBean == null) {
        return;
    }

    int active = poolMXBean.getActiveConnections();

    if (active == 0) {
        if (idleStartTime == null) {
            idleStartTime = Instant.now();
        } else {
            Duration idle = Duration.between(idleStartTime, Instant.now());
            if (!minimized && idle.compareTo(fixedDelayToMinimize) >= 0) {
                logger.info("Minimizing DB pool");
                dataSource.setMinimumIdle(1);
                dataSource.setMaximumPoolSize(2);
                poolMXBean.softEvictConnections();
                minimized = true;
            }
        }
    } else {
        idleStartTime = null;
        if (minimized) {
            logger.info("Restoring DB pool");
            dataSource.setMaximumPoolSize(maxPoolSize);
            dataSource.setMinimumIdle(minPoolSize);
            minimized = false;
        }
    }
}










=============================================================================




pChecklist for coding
Ingress URL of a service-
-	Use lower case
-	Use hyphen(-) if necessary
-	Donâ€™t use camel case, all upper case, only numerical
Jar Naming convention â€“
-	Use Lower case
-	Donâ€™t use camel case, all upper case, only numerical, special characters.
Name of the ingress and jar must be same.
The main service class must contain only framework related code and call to child classes.
Create child classes for calling JVM COBOL classes.
Maintain packages for each category.
Declare objects in global scope â€“ for java classes
Declare objects in local scope â€“ for JVM COBOL classes
Donâ€™t declare of variables in global scope
Donâ€™t use â€˜==â€™ operator for string comparisons
Initialization of string variables
Input validations must have check for null, empty, spaces, length, and mandatory/non - mandatory.
Donâ€™t manipulate the value received from web layer
If manipulation is needed do it after initial validations or at the time of function call.
Create the request bean class based on SD.
All the request parameters must be added in the isEmpty() method of Request Bean Class
When using a parameter from properties file â€“
-	make sure to have an entry for the field in properties file
-	Same naming convention must be used in code as well as in file.
Addition of newly introduced parameters of properties file in code â€“
-	Add the variable to array which is used for initial validations
-	Append the values to variable which is used to set environment
CBS error number should be 4 digits, add zeros at begin wherever applicable
The naming convention of the fields must be updated in Response and error response class as per SD
The data given in response and data in LOG DB must match
Update the value of TXN_NAME, TXN_NO fields of LOG DB table according to the service in the related code
All the commits to LOG DB after initial save must use update method.
Close the resources which are opened
Use try catch around getConnection() method
Use logger statements efficiently
Donâ€™t print any user information inside logger.
Run unit - 
-	The data type of the connection string in JVM COBOL must be SQL data type
-	It must be the last variable in linkage section
-	Pass using BY VALUE
-	getReference() will be show warning in the editor, ignore it

Checklist for creation jar
Ensure there are no problems in the workspace
The service must be down before creation of jar
Addition of cbldat files
Donâ€™t change the folder or file names once the jar has been created.
No addition/removal/rename of jars in the dependency lib after jar creation.

Checklist before the deployment
Maintain versioning of all check-ins in the below mentioned path
Path : \\10.243.6.40\Visual Cobol Microservices Checkin
config.properties and application.properties must have relative paths of the files.
application.properties must contain parameterized version of DB logins.
application.properties must contain the DB parameters set for DB Pooling(thread life time, thread count etc)
Response outline of the service must be placed inside JsonAta folder.
Modify Banner.txt particular to the service.
In DBProperties file, the value of day and ref mode fields must be set to true.
Make sure old jars to be removed and replace it with new one.
Checklist for CR
Feasibility submission â€“ 1-2 days.
Development should not take more than 5 days.
Prepare unit test cases for framework and services
Initial testing using Dev DB data
Once the code is almost finalized, testing should be done on ST DB data
While testing on ST DB data, start internal review (JAVA, COBOL) in parallel.
If all the test cases are passed on ST data and internal review (JAVA, COBOL) done, then go for CHECK-IN/ HP FORTIFY SCAN
WBT should be prepared with DEV DB data.
While promoting CR to ST, if vulnerabilities are raised go with no observations mail from ISD. DGM approval for suppression will be provided at UAT promotion level.
Whenever any new concept is being introduced or changes in framework, deploy and test it on DEV region and then go for ST deployment.
While redeploying a service, donâ€™t modify existing check-in version, and create the next version. [Even for a minor change]
Once the CR is in ST, start gathering data for UAT and test for the same.
Once you get ST PASS, do load testing on ST region and store reports in the below path
	Path: \\10.243.6.40\Visual Cobol Microservices Load Report

NOTE: Donâ€™t manipulate the check-in folders in the path.





package com.tcs.bancs.microservices.config;

import com.zaxxer.hikari.HikariDataSource;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.jdbc.DataSourceBuilder;
import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Component;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.orm.jpa.EntityManagerFactoryBuilder;

import javax.persistence.EntityManagerFactory;
import javax.sql.DataSource;
import java.util.HashMap;

@Component
@Lazy
public class CBSPRNightDbConfig {

    @Value("${prnight.jpa.properties.hibernate.dialect:com.tcs.bancs.microservices.configuration.CustomOracleDialect}")
    private String hibernateDialect;

    @Value("${prnight.datasource.hikari.pool-name}")
    private String poolName;

    @Value("${prnight.datasource.hikari.connectionTimeout}")
    private long connectionTimeout;

    @Value("${prnight.datasource.hikari.idleTimeout}")
    private long idleTimeout;

    @Value("${prnight.datasource.hikari.maxLifetime}")
    private long maxLifetime;

    @Value("${prnight.datasource.hikari.registerMbeans}")
    private boolean registerMbeans;

    private HikariDataSource prnightDataSource;
    private LocalContainerEntityManagerFactoryBean prnightEMF;
    private JpaTransactionManager prnightTxManager;

    private final EntityManagerFactoryBuilder builder;

    public CBSPRNightDbConfig(EntityManagerFactoryBuilder builder) {
        this.builder = builder;
    }

    // ðŸš€ Initialize Database Only When Called (Lazy)
    public synchronized void initialize() {
        if (prnightDataSource != null) {
            return; // already initialized
        }

        // Create the DataSource
        prnightDataSource = (HikariDataSource) DataSourceBuilder
                .create()
                .type(HikariDataSource.class)
                .build();

        prnightDataSource.setPoolName(poolName);
        prnightDataSource.setConnectionTimeout(connectionTimeout);
        prnightDataSource.setIdleTimeout(idleTimeout);
        prnightDataSource.setMaxLifetime(maxLifetime);
        prnightDataSource.setRegisterMbeans(registerMbeans);

        // Hibernate properties
        HashMap<String, Object> props = new HashMap<>();
        props.put("hibernate.dialect", hibernateDialect);

        // Create EntityManagerFactory
        prnightEMF = builder
                .dataSource(prnightDataSource)
                .packages("com.tcs.bancs.microservices.db.model")
                .properties(props)
                .persistenceUnit("prnight")
                .build();

        // Create Transaction Manager
        prnightTxManager = new JpaTransactionManager(prnightEMF.getObject());
    }

    // Getter for DataSource
    public DataSource getDataSource() {
        return prnightDataSource;
    }

    // Getter for EntityManagerFactory
    public EntityManagerFactory getEntityManagerFactory() {
        return prnightEMF != null ? prnightEMF.getObject() : null;
    }

    // Getter for Transaction Manager
    public JpaTransactionManager getTransactionManager() {
        return prnightTxManager;
    }

    // âŒ Shut Down PRNIGHT DB When Not Needed
    public synchronized void shutdown() {
        try {
            if (prnightDataSource != null) {
                prnightDataSource.close();
            }
        } catch (Exception ignored) {}

        prnightDataSource = null;
        prnightEMF = null;
        prnightTxManager = null;
    }
}





package com.tcs.bancs.microservices.config;

import org.springframework.stereotype.Component;

import java.time.Instant;
import java.util.concurrent.atomic.AtomicLong;

@Component
public class RequestActivityTracker {

    private final AtomicLong lastRequestTime = new AtomicLong(Instant.now().toEpochMilli());

    // call when any API hits
    public void updateActivity() {
        lastRequestTime.set(Instant.now().toEpochMilli());
    }

    // scheduler will check this
    public long getLastActivityTime() {
        return lastRequestTime.get();
    }
}



package com.tcs.bancs.microservices.config;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerInterceptor;

import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

@Component
public class ActivityInterceptor implements HandlerInterceptor {

    @Autowired
    private RequestActivityTracker activityTracker;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
        activityTracker.updateActivity();
        return true;
    }
}






package com.tcs.bancs.microservices.config;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class InterceptorConfig implements WebMvcConfigurer {

    @Autowired
    private ActivityInterceptor activityInterceptor;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(activityInterceptor);
    }
}




package com.tcs.bancs.microservices.config;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

@Component
public class DbIdleMonitor {

    @Autowired
    private RequestActivityTracker activityTracker;

    @Autowired
    private CBSPRNightDbConfig dbConfig;

    private static final long IDLE_LIMIT = 10 * 60 * 1000; // 10 minutes

    @Scheduled(fixedRate = 60000)  // runs every 1 min
    public void monitorAndShutdown() {
        long now = System.currentTimeMillis();
        long last = activityTracker.getLastActivityTime();

        if (now - last >= IDLE_LIMIT) {

            if (dbConfig.getDataSource() != null) {
                System.out.println("âš ï¸ No requests for 10 min â€” shutting down PRNIGHT DB connection pool");
                dbConfig.shutdown();
            }
        }
    }
}



package com.tcs.bancs.microservices.service;
import com.tcs.bancs.microservices.enc.utils.SBISFTP;
import java.io.IOException;
import java.io.PrintStream;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.util.Scanner;
import javax.crypto.BadPaddingException;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
public class DecryptionResponse
{
  static String encResponse = new String();
  public static void main(String[] args)
  {
    Scanner sc = new Scanner(System.in);
    System.out.print("Enter AES Key=");
    String accessToken = sc.nextLine();
    System.out.print("\nEnter Encrypted Response file path=\n");
    String encResponsepath = sc.nextLine();
    
    try {
        Files.lines(Paths.get(encResponsepath)).forEach(line -> {
            encResponse += line;            
        });
    } catch (IOException e) {
        System.out.println("Error occurred while fetching the encrypted response file");
    }
        
    try
    {
      String decResponse = SBISFTP.decryptResponse(accessToken, encResponse);
      System.out.println("Decrypted Response>>\n" + decResponse);
    }
    catch (java.security.NoSuchAlgorithmException | InvalidKeyException | NoSuchPaddingException | InvalidAlgorithmParameterException | IllegalStateException | IllegalBlockSizeException | BadPaddingException | IOException e)
    {
      e.printStackTrace();
    }
  }
}
â­
package com.tcs.bancs.microservices.service;

import com.tcs.bancs.microservices.enc.utils.SBISFTP;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.util.Scanner;
import javax.crypto.BadPaddingException;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;

public class DecryptionResponse {
    public static void main(String[] args) {
        try (Scanner sc = new Scanner(System.in)) {
            // Take AES Key from user
            System.out.print("Enter AES Key: ");
            String accessToken = sc.nextLine();

            // Take Encrypted Response File Path
            System.out.print("\nEnter Encrypted Response file path: ");
            String encResponsePath = sc.nextLine();

            // Read file content into StringBuilder
            StringBuilder encResponse = new StringBuilder();
            try {
                Files.lines(Paths.get(encResponsePath)).forEach(encResponse::append);
            } catch (IOException e) {
                System.err.println("Error occurred while fetching the encrypted response file.");
                e.printStackTrace();
                return;
            }

            // Decrypt the response
            try {
                String decResponse = SBISFTP.decryptResponse(accessToken, encResponse.toString());
                System.out.println("Decrypted Response:\n" + decResponse);
            } catch (java.security.NoSuchAlgorithmException | InvalidKeyException | NoSuchPaddingException |
                     InvalidAlgorithmParameterException | IllegalStateException | IllegalBlockSizeException |
                     BadPaddingException | IOException e) {
                System.err.println("Error occurred while decrypting the response.");
                e.printStackTrace();
            }
        }
    }
}




//    SBI Core Banking Project, Kondapur, Hyderabad, India.       *
//*****************************************************************
//                                                                *
//  	           PROGRAM - OpenBankingServicesApp.Java                *
//                                                                *
//*****************************************************************
//                 P R O G R A M    H I S T O R Y                 *
//                                                                *
//   PROGRAMMER    :    DATE       :  SPR NO   :   COMMENTS       *
//----------------------------------------------------------------*
// Naga Sai Ganesh : 15/10/2024    : 24090001  :  MICROSERVICES   *
// Niharika Tammana: 15/10/2024    : 24090001  :  MICROSERVICES   *
//----------------------------------------------------------------*

package com.tcs.bancs.microservices;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration;
import org.springframework.boot.builder.SpringApplicationBuilder;
import org.springframework.boot.web.servlet.support.SpringBootServletInitializer;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Import;
//import org.springframework.data.jpa.repository.config.EnableJpaRepositories;

import com.tcs.bancs.microservices.config.CBSDayDbConfig;
import com.tcs.bancs.microservices.config.CBSNightDbConfig;
import com.tcs.bancs.microservices.config.CBSRefDbConfig;
import springfox.documentation.swagger2.annotations.EnableSwagger2;

@SpringBootApplication(exclude = { DataSourceAutoConfiguration.class, // HibernateJpaAutoConfiguration.class,
		DataSourceTransactionManagerAutoConfiguration.class }, scanBasePackages = "com.tcs.bancs.microservices")
@ComponentScan(basePackages = { "com.tcs.bancs.microservices", "com.tcs.bancs.microservices.config",
		"com.tcs.bancs.api", "com.tcs.bancs.microservices.interceptor", "com.tcs.bancs.microservices.api",
		"com.tcs.bancs.microservices.model", "com.tcs.bancs.microservices.util", "com.tcs.bancs.microservices",
		"com.tcs.bancs.microservices.impl", "com.tcs.bancs.microservices.repository.day",
		"com.tcs.bancs.microservices.repository.night", "com.tcs.bancs.microservices.repository.ref",
		"com.tcs.bancs.microservices.exception", "com.tcs.bancs.microservices.mappings",
		"com.tcs.bancs.microservices.model" })
@EnableSwagger2
@Import({ CBSDayDbConfig.class, CBSNightDbConfig.class, CBSRefDbConfig.class })
public class OpenBankingServicesApp extends SpringBootServletInitializer {
	private static Logger LOGGER = LoggerFactory.getLogger(OpenBankingServicesApp.class);

	public static void main(String[] args) {

		if (System.getProperty("ChannelsPropConfigPath") == null) {
			LOGGER.info(
					"Path to config property file is not set! Please set the system variable \"ChannelsPropConfigPath\" with the path to the config file.");
			LOGGER.info("Execution Finished with Error!");
		}

		SpringApplication.run(OpenBankingServicesApp.class, args);

	}
	
	
	protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {
		return builder.sources(OpenBankingServicesApp.class);
	}

}


public class Main {
    public static void main(String[] args) {
        String decResponse = "123,456,789{abc,def},[1,000,2,000],xyz";
        
        // Split the string while preserving commas between numbers
        // Use negative lookahead (?![0-9]) and negative lookbehind (?<![0-9]) to avoid splitting on commas between digits
        String[] parts = decResponse.split(",(?![0-9])|(?<![0-9]),|[\\{\\}\\[\\]]+");
        
        // Print the result
        for (String part : parts) {
            System.out.println(part);
        }
    }
}


if (StringUtils.isAlpha(opcode)) {
				if (opcode.equals("F") || opcode.equals("M") || opcode.equals("P") || opcode.equals("E")) {






 RunUnit run1 = new RunUnit();
		 try (Connection connection = datasource.getConnection()){
			
	            run1.Add(jvm60457);
 	    		run1.Call("JVM60457", cif_number.get_Reference(), opt_flag.get_Reference(), branch_num.get_Reference(), teller_num.get_Reference(), out_cif_details.get_Reference(), out_account_array.get_Reference(),  out_error_num.get_Reference(), Rec_Area.get_Reference(),connection);
 	    		errno = out_error_num.getJvmOutErrorNo();
		 } catch (SQLException e) {
			 errno = "3293";

		}
		 
			 cif_details = out_cif_details.getJvmOutCifDetails();
			index = 0;
			while (index <= 9999) {
				String account_details = out_account_array.getJvmOutput60457Output(index);
				if (!account_details.trim().isEmpty()) {
					Output_Acc = Output_Acc + account_details;
					index+=1;
				}
				else {
					break;
				}
			}
			  run1.close();




import com.microfocus.cobol.runtime.RunUnit;
import java.sql.Connection;
import java.sql.SQLException;

public class RunUnitMonitor {
    public static void main(String[] args) {
        RunUnit run1 = new RunUnit();
        System.out.println("RunUnit Created: " + run1);  // Print RunUnit reference

        Runtime runtime = Runtime.getRuntime();
        long memoryBefore = runtime.totalMemory() - runtime.freeMemory();
        System.out.println("Memory Before RunUnit Execution: " + memoryBefore + " bytes");

        try (Connection connection = datasource.getConnection()) {
            System.out.println("Database connection established.");

            // Add the COBOL program to the RunUnit
            run1.Add(jvm60457);
            System.out.println("COBOL program added to RunUnit.");

            // Call the COBOL program
            run1.Call("JVM60457", 
                      cif_number.get_Reference(), 
                      opt_flag.get_Reference(), 
                      branch_num.get_Reference(), 
                      teller_num.get_Reference(), 
                      out_cif_details.get_Reference(), 
                      out_account_array.get_Reference(),  
                      out_error_num.get_Reference(), 
                      Rec_Area.get_Reference(), 
                      connection);
            System.out.println("COBOL program executed.");

            errno = out_error_num.getJvmOutErrorNo();
        } catch (SQLException e) {
            errno = "3293";
            System.out.println("SQL Exception occurred: " + e.getMessage());
        }

        // Processing output details
        cif_details = out_cif_details.getJvmOutCifDetails();
        index = 0;
        while (index <= 9999) {
            String account_details = out_account_array.getJvmOutput60457Output(index);
            if (!account_details.trim().isEmpty()) {
                Output_Acc = Output_Acc + account_details;
                index += 1;
            } else {
                break;
            }
        }

        // Closing RunUnit
        run1.close();
        System.out.println("RunUnit closed successfully.");

        // Suggest garbage collection
        run1 = null;
        System.gc();
        System.runFinalization();

        // Check memory after RunUnit execution
        long memoryAfter = runtime.totalMemory() - runtime.freeMemory();
        System.out.println("Memory After RunUnit Execution: " + memoryAfter + " bytes");

        if (memoryAfter > memoryBefore) {
            System.out.println("âš ï¸ Possible Memory Leak Detected!");
        } else {
            System.out.println("âœ… Memory Released Successfully.");
        }
    }
}






import com.microfocus.cobol.runtime.RunUnit;
import java.lang.ref.PhantomReference;
import java.lang.ref.ReferenceQueue;
import java.sql.Connection;
import java.sql.SQLException;

public class RunUnitMonitor {
    private static ReferenceQueue<RunUnit> refQueue = new ReferenceQueue<>();

    static class RunUnitCleaner extends PhantomReference<RunUnit> {
        public RunUnitCleaner(RunUnit run1) {
            super(run1, refQueue);
        }

        public void cleanUp() {
            System.out.println("RunUnit is no longer referenced. Cleaning up...");
        }
    }

    public static void main(String[] args) {
        RunUnit run1 = new RunUnit();
        RunUnitCleaner cleaner = new RunUnitCleaner(run1);
        System.out.println("RunUnit Created: " + run1);

        long memoryBefore = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
        System.out.println("Memory Before Execution: " + memoryBefore + " bytes");

        try (Connection connection = datasource.getConnection()) {
            System.out.println("Database connection established.");
            run1.Add(jvm60457);
            run1.Call("JVM60457", 
                      cif_number.get_Reference(), 
                      opt_flag.get_Reference(), 
                      branch_num.get_Reference(), 
                      teller_num.get_Reference(), 
                      out_cif_details.get_Reference(), 
                      out_account_array.get_Reference(),  
                      out_error_num.get_Reference(), 
                      Rec_Area.get_Reference(), 
                      connection);
            System.out.println("COBOL program executed.");
        } catch (SQLException e) {
            System.out.println("SQL Exception: " + e.getMessage());
        }

        // Close RunUnit explicitly
        run1.close();
        System.out.println("RunUnit closed successfully.");

        // Nullify the reference and let the PhantomReference handle cleanup
        run1 = null;

        // Monitor memory after execution
        long memoryAfter = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
        System.out.println("Memory After Execution: " + memoryAfter + " bytes");

        // Check for cleanup
        if (refQueue.poll() != null) {
            cleaner.cleanUp();
        }

        if (memoryAfter < memoryBefore) {
            System.out.println("âœ… Memory released successfully.");
        } else {
            System.out.println("âš ï¸ Possible memory leak detected!");
        }
    }
}





public class YONO_Child {
	
	Logger logger = LoggerFactory.getLogger(YONO_Child.class);
	   Connection connection;

	public List<String> callYONOEnquiryChild(String branch_number,  String tellerno, String cifno, String option_flag, DataSource datasource, String commonArea) throws InterruptedException, ExecutionException {
		int index;
		String Output_Acc = "";
		String cif_details;
		String errno;
		   JVM60457 jvm60457 = new JVM60457();
		
		logger.info("VC------------------------YONO Enquiry Child Service Started------------------------VC");
		
		JvmIn60457CifNo     cif_number        = new JvmIn60457CifNo();
		JvmIn60457OptnFlag  opt_flag          = new JvmIn60457OptnFlag();
		JvmInBranchNo       branch_num        = new JvmInBranchNo();
		JvmInTellerNo       teller_num        = new JvmInTellerNo();
		LsRecordArea 		Rec_Area          = new LsRecordArea();
		JvmOutCifDetails    out_cif_details   = new JvmOutCifDetails();
		JvmArrayOutputOut   out_account_array = new JvmArrayOutputOut();
		JvmOutErrorNo       out_error_num     = new JvmOutErrorNo();
         

		
		teller_num.setJvmInTellerNo(String.format("%016d", new BigInteger(tellerno)));
		cif_number.setJvmIn60457CifNo(String.format("%017d", new BigInteger(cifno)));
		opt_flag.setJvmIn60457OptnFlag(option_flag);
		branch_num.setJvmInBranchNo(branch_number);
		Rec_Area.setLsRecordArea(commonArea);
		 RunUnit run1 = new RunUnit();
		
		 System.out.println("RunUnit Created: " + run1);  // Print RunUnit reference

	        Runtime runtime = Runtime.getRuntime();
	        long memoryBefore = runtime.totalMemory() - runtime.freeMemory();
	        System.out.println("Memory Before RunUnit Execution: " + memoryBefore + " bytes");
	       
		 try (Connection connection = datasource.getConnection()){
			
	            run1.Add(jvm60457);
	         
	            System.out.println("COBOL program added to RunUnit.");
	           
 	    		run1.Call("JVM60457", cif_number.get_Reference(), opt_flag.get_Reference(), branch_num.get_Reference(), teller_num.get_Reference(), out_cif_details.get_Reference(), out_account_array.get_Reference(),  out_error_num.get_Reference(), Rec_Area.get_Reference(),connection);
 	    		errno = out_error_num.getJvmOutErrorNo();
		 } catch (SQLException e) {
	     errno = "VC010";
			 errno = "3293";

		}
		 
			 cif_details = out_cif_details.getJvmOutCifDetails();
			index = 0;
			while (index <= 9999) {
				String account_details = out_account_array.getJvmOutput60457Output(index);
				if (!account_details.trim().isEmpty()) {
					Output_Acc = Output_Acc + account_details;
					index+=1;
				}
				else {
					break;
				}
			}
			  run1.close();
			  System.out.println("RunUnit closed successfully.");
		        run1 = null;
		        long memoryAfter = runtime.totalMemory() - runtime.freeMemory();
		        System.out.println("Memory After RunUnit Execution: " + memoryAfter + " bytes");

		        if (memoryAfter > memoryBefore) {
		            System.out.println("Possible Memory Leak Detected");
		        } else {
		            System.out.println(" Memory Released Successfully.");
		        }
		    
			List<String> res = new ArrayList<>();
			res.add(cif_details);
			if (!Output_Acc.isEmpty()) {
				res.add(Output_Acc.substring(0, Output_Acc.length() - 317));
			}
			else {
				res.add(Output_Acc);
			}
			
			res.add(String.valueOf(index-1));
			res.add(errno);
			
			return res;
	}
	}




-----------------------------------


public class YONO_Child {
	
	Logger logger = LoggerFactory.getLogger(YONO_Child.class);
	   Connection connection;

	public List<String> callYONOEnquiryChild(String branch_number,  String tellerno, String cifno, String option_flag, DataSource datasource, String commonArea) throws InterruptedException, ExecutionException {
		int index;
		String Output_Acc = "";
		String cif_details;
		String errno;
		   JVM60457 jvm60457 = new JVM60457();
		
		logger.info("VC------------------------YONO Enquiry Child Service Started------------------------VC");
		
		JvmIn60457CifNo     cif_number        = new JvmIn60457CifNo();
		JvmIn60457OptnFlag  opt_flag          = new JvmIn60457OptnFlag();
		JvmInBranchNo       branch_num        = new JvmInBranchNo();
		JvmInTellerNo       teller_num        = new JvmInTellerNo();
		LsRecordArea 		Rec_Area          = new LsRecordArea();
		JvmOutCifDetails    out_cif_details   = new JvmOutCifDetails();
		JvmArrayOutputOut   out_account_array = new JvmArrayOutputOut();
		JvmOutErrorNo       out_error_num     = new JvmOutErrorNo();
         

		
		teller_num.setJvmInTellerNo(String.format("%016d", new BigInteger(tellerno)));
		cif_number.setJvmIn60457CifNo(String.format("%017d", new BigInteger(cifno)));
		opt_flag.setJvmIn60457OptnFlag(option_flag);
		branch_num.setJvmInBranchNo(branch_number);
		Rec_Area.setLsRecordArea(commonArea);
		 RunUnit run1 = new RunUnit();
		 RunUnit run2 = new RunUnit();
		 System.out.println("RunUnit Created: " + run1);  // Print RunUnit reference
		
        Runtime runtime = Runtime.getRuntime();
	        long memoryBefore = runtime.totalMemory() - runtime.freeMemory();
	        System.out.println("Memory Before RunUnit Execution: " + memoryBefore + " bytes");
	        //Changed
		 try (Connection connection = datasource.getConnection()){
			
	            run1.Add(jvm60457);
	            //Changed
	            System.out.println("COBOL program added to RunUnit.");
	            //Changed
 	    		run1.Call("JVM60457", cif_number.get_Reference(), opt_flag.get_Reference(), branch_num.get_Reference(), teller_num.get_Reference(), out_cif_details.get_Reference(), out_account_array.get_Reference(),  out_error_num.get_Reference(), Rec_Area.get_Reference(),connection);
 	    		errno = out_error_num.getJvmOutErrorNo();
		 } catch (SQLException e) {
			 errno = "3293";
		}
		 
			 cif_details = out_cif_details.getJvmOutCifDetails();
			index = 0;
			while (index <= 9999) {
				String account_details = out_account_array.getJvmOutput60457Output(index);
				if (!account_details.trim().isEmpty()) {
					Output_Acc = Output_Acc + account_details;
					index+=1;
				}
				else {
					break;
				}
			}
			  run1.close();
			  System.out.println("RunUnit closed successfully.");
		      run1=run2;	       
		        long memoryAfter = runtime.totalMemory() - runtime.freeMemory();
		        System.out.println("Memory After Execution: " + memoryAfter + " bytes");

		        if (memoryAfter > memoryBefore) {
		            System.out.println("Possible Memory Leak Detected");
		        } else {
		            System.out.println("Memory Released Successfully.");
		        }
		    
			List<String> res = new ArrayList<>();
			res.add(cif_details);
			if (!Output_Acc.isEmpty()) {
				res.add(Output_Acc.substring(0, Output_Acc.length() - 317));
			}
			else {
				res.add(Output_Acc);
			}
			
			res.add(String.valueOf(index-1));
			res.add(errno);
			
			return res;
	}
	}








=============================================================================================================

package com.tcs.bancs.microservices.util;

import com.tcs.bancs.microservices.config.CBSDayDbConfig;
import com.tcs.bancs.microservices.config.CacheConfig;
import com.tcs.bancs.microservices.db.model.Sysc;
import com.tcs.bancs.microservices.domain.DBData;
import com.tcs.bancs.microservices.exception.RuleAccessTechnicalException;
import com.tcs.bancs.microservices.interceptor.AggregatorRequestHandlerInterceptor;
import com.tcs.bancs.microservices.repository.night.SyscRepository;
import java.io.IOException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;
import javax.servlet.http.HttpServletRequest;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.Import;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;














@Service
@Import({CacheConfig.class})
public class DBProcess
{
@Autowired(required = false)
SyscRepository SyscRepository;
public static long dbStartTimeMillis;
@Autowired
ApplicationContext context;
@Autowired
HttpServletRequest HttpServletRequest;
@Autowired
DaoUtilities daoUtil;
public Integer[] pageDetails = new Integer[2];
public static Integer[] recordNumParam = new Integer[2];

Logger logger = LoggerFactory.getLogger(DBProcess.class);






public static final int defaultRowNumber = 10;







public DBData readSyscTable() {
DBData dbData = new DBData();
Sysc oSysc = new Sysc();

oSysc = this.SyscRepository.FetchSyscDetails(AggregatorConfigLoader.syscProperties.getProperty("TargetLevel"), AggregatorConfigLoader.syscProperties
.getProperty("RegionNo"), AggregatorConfigLoader.syscProperties
.getProperty("EntityNo"), AggregatorConfigLoader.syscProperties
.getProperty("SystemNo"), AggregatorConfigLoader.syscProperties
.getProperty("NodeNo"), AggregatorConfigLoader.syscProperties
.getProperty("ReplicaTypeX"), AggregatorConfigLoader.syscProperties
.getProperty("ReplicaNo"));
dbData.setAPP(oSysc.getSyscVariable().substring(10, 11));

dbData.setMASTER_1(oSysc.getSyscVariable().substring(37, 45).trim());
dbData.setMASTER_2(oSysc.getSyscVariable().substring(52, 60).trim());
dbData.setIN_USE(oSysc.getSyscVariable().substring(67, 75).trim());
return dbData;
}










public DBData fetchDbRegionDetails(String beanName, DBData dbData) throws Exception {
String type = "0";

if (dbData.getAPP().equals("D")) {

dbData.setDBINDICATOR("DD");
dbData.setACCESS_TYPE(type);
} else {
type = AggregatorConfigLoader.propertiesConfiguration.getProperty(beanName.toUpperCase());



String DBIndicator = dbData.getIN_USE().equals(CBSDayDbConfig.connectionType.trim()) ? "DN" : "RN";


dbData.setDBINDICATOR(DBIndicator);
dbData.setACCESS_TYPE(type);
} 
return dbData;
}




























public <T> T fetchRepositories(Object dbModelBean, String repoBeanName, String repositoryName, String repoMethod, boolean pagination, boolean isList, ArrayList<Object> queryParams) throws Exception {
T nightData = null;



try {
DBData dbData = new DBData();
dbData.setDBINDICATOR("DD");
dbData.setACCESS_TYPE("0");







if (pagination)
getPageDetails(); 
if (isList) {
getRowNumber();
}
if (AggregatorConfigLoader.applicationDBRregionType.equals("24")) {

dbData = (DBData)this.HttpServletRequest.getAttribute("DBData");

dbData = fetchDbRegionDetails(repoBeanName, dbData);
} 


String repositoryDDName = StringUtils.uncapitalize(RepoImplMapping2RepositoryBean("DD", repositoryName));


if (!"DD".equals(dbData.getDBINDICATOR())) {



String repositoryNight = StringUtils.uncapitalize(
RepoImplMapping2RepositoryBean("DN", repositoryName));












nightData = invokeRepository(dbModelBean, repositoryNight, repoMethod, queryParams, this.pageDetails[0], this.pageDetails[1], recordNumParam[0], pagination, isList);











if (nightData != null && dbData
.getACCESS_TYPE().equalsIgnoreCase("3")) {
return nightData;
}


if ("RN".equals(dbData.getDBINDICATOR())) {

String repositoryRef = StringUtils.uncapitalize(
RepoImplMapping2RepositoryBean("RN", repositoryName));
if (isList || pagination) {
return invokeListRepository(nightData, dbModelBean, repositoryRef, repoMethod, pagination, queryParams);
}
if (nightData == null) {
return invokeRepository(dbModelBean, repositoryRef, repoMethod, queryParams, this.pageDetails[0], this.pageDetails[1], recordNumParam[0], pagination, isList);
}
} 





if (isList || pagination) {
return invokeListRepository(nightData, dbModelBean, repositoryDDName, repoMethod, pagination, queryParams);
}
} 

















if (nightData == null) {
return invokeRepository(dbModelBean, repositoryDDName, repoMethod, queryParams, this.pageDetails[0], this.pageDetails[1], recordNumParam[0], pagination, isList);

}
}
catch (Exception e) {
throw e;
} 





return nightData;
}












































public <T> T invokeListRepository(T data, Object dbModelBean, String repositoryName, String repoMethod, boolean pagination, ArrayList<Object> queryParams) throws Exception {
Integer count = null;
List<T> list2 = new ArrayList<>();

if (pagination) {
Page<T> pagedResult = (Page<T>)data;

List<T> list3 = pagedResult.getContent();

if (this.pageDetails[1] != null && list3.size() != this.pageDetails[1].intValue()) {

count = (Integer)this.daoUtil.<T>calculatePageSize(list3, this.pageDetails[1].intValue());
if (count.intValue() != 0) {
queryParams.remove(queryParams.size() - 1);

Page<T> pagedResult2 = invokeRepository(dbModelBean, repositoryName, repoMethod, queryParams, this.pageDetails[0], count, null, pagination, false);


list2 = pagedResult2.getContent();
} 
} 








List<T> list4 = this.daoUtil.union(list3, list2);
return (T)new PageImpl(list4);
} 


List<T> list1 = (List<T>)data;

if (list1.size() == 0)
{
return invokeRepository(dbModelBean, repositoryName, repoMethod, queryParams, this.pageDetails[0], this.pageDetails[1], recordNumParam[0], pagination, true);
}




int listSize = 0;
boolean isRange = false;
if (recordNumParam.length == 2 && recordNumParam[1] != null) {
listSize = recordNumParam[1].intValue() - recordNumParam[0].intValue();
isRange = true;
} 

if (list1.size() != listSize) {
count = (Integer)this.daoUtil.<T>calculatePageSize(list1, listSize);
if (count.intValue() != 0) {

queryParams.remove(queryParams.size() - 1);

T data2 = invokeRepository(dbModelBean, repositoryName, repoMethod, queryParams, null, null, count, pagination, true);

list2 = (List<T>)data2;
} 
} 





List<T> returnObjList = this.daoUtil.union(list1, list2);
return (T)returnObjList;
}





public Integer[] getPageDetails() {
if (AggregatorRequestHandlerInterceptor.requestParamMap != null) {

int pageNumber = 0;

if ((AggregatorRequestHandlerInterceptor.requestParamMap.containsKey("page") && (AggregatorRequestHandlerInterceptor.requestParamMap
.containsKey("pageSize") || AggregatorRequestHandlerInterceptor.requestParamMap

.containsKey("page-size"))) || (this.HttpServletRequest
.getAttribute("page") != null && this.HttpServletRequest
.getAttribute("pageSize") != null)) {

if (this.HttpServletRequest.getParameter("page") == null) {


pageNumber = ((Integer)this.HttpServletRequest.getAttribute("page") == null) ? pageNumber : ((Integer)this.HttpServletRequest.getAttribute("page")).intValue();
} else {
pageNumber = Integer.valueOf(this.HttpServletRequest.getParameter("page")).intValue();
} 
if (pageNumber != 0)
pageNumber--; 
this.pageDetails[0] = Integer.valueOf(pageNumber);
if (this.HttpServletRequest.getParameter("pageSize") == null && this.HttpServletRequest
.getParameter("page-size") == null) {
this.pageDetails[1] = ((Integer)this.HttpServletRequest.getAttribute("pageSize") == null) ? null : (Integer)this.HttpServletRequest

.getAttribute("pageSize");
}
else if (this.HttpServletRequest.getParameter("pageSize") != null) {
this.pageDetails[1] = Integer.valueOf(this.HttpServletRequest.getParameter("pageSize"));
} else if (this.HttpServletRequest.getParameter("page-size") != null) {
this.pageDetails[1] = Integer.valueOf(this.HttpServletRequest.getParameter("page-size"));
} 
} 
} 








return this.pageDetails;
}






public Integer[] getRowNumber() {
if (AggregatorRequestHandlerInterceptor.requestParamMap.containsKey("recordNum") || this.HttpServletRequest
.getAttribute("recordNum") != null) {

recordNumParam[0] = Integer.valueOf((AggregatorRequestHandlerInterceptor.requestParamMap.get("recordNum") == null) ? (
(this.HttpServletRequest.getAttribute("recordNum") == null) ? 0 : ((Integer)this.HttpServletRequest
.getAttribute("recordNum")).intValue()) : ((Integer)AggregatorRequestHandlerInterceptor.requestParamMap
.get("recordNum")).intValue());

}
else if ((AggregatorRequestHandlerInterceptor.requestParamMap.containsKey("startRecordNum") || this.HttpServletRequest
.getAttribute("startRecordNum") != null) && (AggregatorRequestHandlerInterceptor.requestParamMap
.containsKey("endRecordNum") || this.HttpServletRequest
.getAttribute("endRecordNum") != null)) {

recordNumParam[0] = Integer.valueOf(
(AggregatorRequestHandlerInterceptor.requestParamMap.get("startRecordNum") == null) ? (
(this.HttpServletRequest.getAttribute("startRecordNum") == null) ? 0 : ((Integer)this.HttpServletRequest

.getAttribute("startRecordNum")).intValue()) : ((Integer)AggregatorRequestHandlerInterceptor.requestParamMap
.get("startRecordNum")).intValue());
recordNumParam[1] = Integer.valueOf((AggregatorRequestHandlerInterceptor.requestParamMap.get("endRecordNum") == null) ? (
(this.HttpServletRequest.getAttribute("endRecordNum") == null) ? 0 : ((Integer)this.HttpServletRequest
.getAttribute("endRecordNum")).intValue()) : ((Integer)AggregatorRequestHandlerInterceptor.requestParamMap
.get("endRecordNum")).intValue());
}
else {

recordNumParam[0] = Integer.valueOf(0);
} 

return recordNumParam;
}







public <T> T invokeRepository(Object dbModelBean, String repositoryName, String repoMethod, ArrayList<Object> queryParams, Integer page, Integer pageSize, Integer recordNum, boolean isPagination, boolean isList) throws Exception {
T t = null;
if (dbModelBean != null) {

Object inputData = null;
Class[] cArg = new Class[1];

if (dbModelBean != null) {
inputData = dbModelBean;
}
cArg[0] = inputData.getClass();

t = (T)this.context.getBean(repositoryName).getClass().getDeclaredMethod(repoMethod, cArg).invoke(this.context.getBean(repositoryName), new Object[] { inputData });


}
else if (queryParams != null) {

if (isPagination) {
if (page == null && pageSize == null) {
queryParams.add(null);
} else {

PageRequest pageRequest = PageRequest.of(page.intValue(), pageSize.intValue());
queryParams.add(pageRequest);
} 
}


if (isList && recordNum.intValue() != 0) {
queryParams.add(recordNum);
}
Class[] cArg = new Class[queryParams.size()];
Object[] data = new Object[queryParams.size()];
Object[] inputData = new Object[queryParams.size()];
for (int i = 0; i < queryParams.size(); i++) {


if (isPagination && queryParams.get(i) != null && queryParams.get(i).getClass() == PageRequest.class) {
cArg[cArg.length - 1] = Pageable.class;

}
else if (queryParams.get(i) == null) {
cArg[i] = String.class;
} else {
cArg[i] = queryParams.get(i).getClass();
} 
data[i] = queryParams.get(i);


inputData[i] = queryParams.get(i);
} 


t = (T)this.context.getBean(repositoryName).getClass().getDeclaredMethod(repoMethod, cArg).invoke(this.context.getBean(repositoryName), inputData);

}
else {

t = (T)this.context.getBean(repositoryName).getClass().getDeclaredMethod(repoMethod, new Class[0]).invoke(this.context.getBean(repositoryName), new Object[0]);
} 






return t;
}




public <T> T fetchRepository(Object dbModelBean, String repoBeanName, String repositoryName, String repoMethod, Object rowNum, boolean isList, ArrayList<Object> queryParams) throws Exception {
try {
long dbStartTimeMillis = System.currentTimeMillis();


Object returnObjData = null;

DBData dbData = new DBData();
dbData.setDBINDICATOR("DD");
dbData.setACCESS_TYPE("0");

if (AggregatorConfigLoader.applicationDBRregionType.equals("24")) {

dbData = (DBData)this.HttpServletRequest.getAttribute("DBData");

dbData = fetchDbRegionDetails(repoBeanName, dbData);
} 

String DBIndicator = dbData.getDBINDICATOR();

String primaryRepositoryName = RepoImplMapping2RepositoryClass(DBIndicator, repositoryName);

String secondRepositoryName = "";
Class<?> secondaryRepoClass = null;

Method secondaryRepoImplMethod = null;
boolean isSecondaryRepo = false;
if (!"DD".equals(dbData.getDBINDICATOR())) {
isSecondaryRepo = true;

if ("DN".equals(dbData.getDBINDICATOR())) {
secondRepositoryName = RepoImplMapping2RepositoryClass("DD", repositoryName);
}
else {

secondRepositoryName = primaryRepositoryName;
primaryRepositoryName = RepoImplMapping2RepositoryClass("RN", repositoryName);
} 
} 



Class<?> primaryRepoClass = Class.forName(primaryRepositoryName);

if (isSecondaryRepo) {
secondaryRepoClass = Class.forName(secondRepositoryName);
}



if (dbModelBean != null || rowNum != null) {





Object inputData = rowNum;

Class[] cArg = new Class[1];

if (dbModelBean != null) {
inputData = dbModelBean;
}
cArg[0] = inputData.getClass();
Method primaryRepoImplMethod = primaryRepoClass.getDeclaredMethod(repoMethod, cArg);

if (isSecondaryRepo) {
secondaryRepoImplMethod = secondaryRepoClass.getDeclaredMethod(repoMethod, cArg);
}








returnObjData = invokeRepositoryMethods(dbData, primaryRepoClass, secondaryRepoClass, primaryRepoImplMethod, secondaryRepoImplMethod, repoMethod, isList, rowNum, inputData, null);



}
else if (queryParams != null) {
Class[] cArg = new Class[queryParams.size()];
Object[] data = new Object[queryParams.size()];
Object[] inputData = new Object[queryParams.size()];
for (int i = 0; i < queryParams.size(); i++) {

cArg[i] = queryParams.get(i).getClass();
data[i] = queryParams.get(i);

inputData[i] = queryParams.get(i);
} 
Method primaryRepoImplMethod = primaryRepoClass.getDeclaredMethod(repoMethod, cArg);

if (isSecondaryRepo) {
secondaryRepoImplMethod = secondaryRepoClass.getDeclaredMethod(repoMethod, cArg);
}


returnObjData = invokeRepositoryMethods(dbData, primaryRepoClass, secondaryRepoClass, primaryRepoImplMethod, secondaryRepoImplMethod, repoMethod, isList, rowNum, null, inputData);


}
else {


Method primaryRepoImplMethod = primaryRepoClass.getDeclaredMethod(repoMethod, new Class[0]);
if (isSecondaryRepo) {
secondaryRepoImplMethod = secondaryRepoClass.getDeclaredMethod(repoMethod, new Class[0]);
}


returnObjData = invokeRepositoryMethods(dbData, primaryRepoClass, secondaryRepoClass, primaryRepoImplMethod, secondaryRepoImplMethod, repoMethod, isList, rowNum, null, null);
} 






return (T)returnObjData;
}
catch (Exception e) {


throw e;
} 
}
























public <T> T invokeRepositoryMethods(DBData dbData, Class primaryRepoClass, Class secondaryRepoClass, Method primaryRepoImplMethod, Method secondaryRepoImplMethod, String repoMethod, boolean isList, Object rowNum, Object inputData, Object[] inputDataArr) throws Exception {
Object object1 = null;
Object returnObj = new Object();
List<Object> returnObjList = new ArrayList();
long startTime = System.currentTimeMillis();


try {
if (isList) {
if (inputData != null) {
returnObjList = (List<Object>)primaryRepoImplMethod.invoke(this.context.getBean(primaryRepoClass), new Object[] { inputData });
}
else if (inputDataArr != null) {

returnObjList = (List<Object>)primaryRepoImplMethod.invoke(this.context.getBean(primaryRepoClass), inputDataArr);
} else {

returnObjList = (List<Object>)primaryRepoImplMethod.invoke(this.context.getBean(primaryRepoClass), new Object[0]);
} 
object1 = returnObjList;

}
else if (inputData != null) {
object1 = primaryRepoImplMethod.invoke(this.context.getBean(primaryRepoClass), new Object[] { inputData });
} else if (inputDataArr != null) {

object1 = primaryRepoImplMethod.invoke(this.context.getBean(primaryRepoClass), inputDataArr);
} else {

object1 = primaryRepoImplMethod.invoke(this.context.getBean(primaryRepoClass), new Object[0]);
} 


if (dbData.getACCESS_TYPE().equals("1")) {
List<Object> list = null;

Integer count = Integer.valueOf(0);
int rowNumber = 0;

if (rowNum == null) {
rowNumber = 10;
} else {

rowNumber = Integer.parseInt(rowNum.toString());
} 
if (isList) {

if (returnObjList.size() != rowNumber) {
count = (Integer)this.daoUtil.<Object>calculatePageSize(returnObjList, rowNumber);
if (count.intValue() != 0) {
List<Object> secondaryList = new ArrayList();
Class[] cArg = new Class[1];
cArg[0] = count.getClass();

if (inputData != null) {

secondaryList = (List<Object>)secondaryRepoImplMethod.invoke(this.context.getBean(secondaryRepoClass), new Object[] { count });
} else if (inputDataArr != null) {

secondaryList = (List<Object>)secondaryRepoImplMethod.invoke(this.context.getBean(secondaryRepoClass), inputDataArr);
} else {

secondaryList = (List<Object>)secondaryRepoImplMethod.invoke(this.context.getBean(secondaryRepoClass), new Object[] { count });
} 
returnObjList = this.daoUtil.union(returnObjList, secondaryList);
} 
} 

list = returnObjList;


}
else if (list == null) {

if (inputData != null) {
Object object = secondaryRepoImplMethod.invoke(this.context.getBean(secondaryRepoClass), new Object[] { inputData });
} else if (inputDataArr != null) {

Object object = secondaryRepoImplMethod.invoke(this.context.getBean(secondaryRepoClass), inputDataArr);
} else {

object1 = secondaryRepoImplMethod.invoke(this.context.getBean(secondaryRepoClass), new Object[0]);
}

} 
} 
} catch (Exception e) {

this.logger.error("Error at LineNumber ==> DBPROCESS : EXCEPTION");

throw new Exception();
} 




return (T)object1;
}



public String RepoImplMapping2RepositoryClass(String dbIndicator, String repoName) throws RuleAccessTechnicalException, IOException {
String className = "";
if (dbIndicator.equals("DD")) {
className = "com.tcs.bancs.microservices.repository.day." + repoName + "DayRepo";
}
else if (dbIndicator.equals("DN")) {
className = "com.tcs.bancs.microservices.repository.night." + repoName + "NightRepo";
}
else if (dbIndicator.equals("RN")) {
className = "com.tcs.bancs.microservices.repository.ref." + repoName + "RefRepo";
} 

return className;
}


public String RepoImplMapping2RepositoryBean(String dbIndicator, String repoName) throws RuleAccessTechnicalException, IOException {
String className = "";
if (dbIndicator.equals("DD")) {
className = repoName + "DayRepo";
} else if (dbIndicator.equals("DN")) {
className = repoName + "NightRepo";
} else if (dbIndicator.equals("RN")) {
className = repoName + "RefRepo";
} 
return className;
}
}
 YBANCS   D                          w012band
	































@RestController
@Api(value = "Aggregation_API", description = " ", tags = { "Aggregation API" })
@RequestMapping("/")
@Cacheable
@CacheEvict
public class YONO_Enquiry_Service {

//////////////////////////////////////////////////////////////////////////--------ENV VARIABLES STARTED--------\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
	
	@Autowired
	AggregationServiceImpl aggregationServiceImpl;

	@Autowired
	MigenqDetailsRepositoryImpl migDetails;
	
	@Autowired
	TelmDetailDayRepo telmRepo;
	
	@Autowired
	CrddDetailDayRepo crddRepo;
	
	@Autowired
	DBProcess dbProcess;
	
	  //START OF IR 25040080 
	@Autowired
	SyscDetailNightRepo syscReponight;
	  //END OF IR 25040080 

	@Value("${UTENVCALS-BANCS-TRACE-STATE}")
	private String bancsTraceState;

	@Value("${UTENVCALS-MASTER-DQPTYPE}")
	private String masterDQType;

	@Value("${UTENVCALS-BANCS-HOST}")
	private String bancsHost;

	@Value("${UTENVCALS-FNS-SYSNUM}")
	private String fnsSysnum;

	@Value("${UTENVCALS-CTRL-SYSNUM}")
	private String ctrlSysnum;

	@Value("${UTENVCALS-DAY-SYSNUM}")
	private String daySysnum;

	@Value("${UTENVCALS-NIGHT-SYSNUM}")
	private String nightSysnum;

	@Value("${UTENVCALS-NON24H-SYSNUM}")
	private String non24hsum;

	@Value("${UTENVCALS-DEF-RMODE}")
	private String defRMode;

	@Value("${UTENVCALS-MASTER-DB-1}")
	private String masterDB1;

	@Value("${UTENVCALS-MASTER-DB-2}")
	private String masterDB2;

	@Value("${UTENVCALS-SERVICES-FLAG}")
	private String servicesFlag;

	@Value("${VC-MS-SERVICE-ID}")
	private String serviceid;
	
	@Value("${cif.response.outline.location}")
	private String CIF_RES_FILE_PATH;
	
	@Value("${acc.response.outline.location}")
	private String ACC_RES_FILE_PATH;
	
	@Value("${UTENVCALS-INSPARAM-FLAG}")
	private String INSPARAM_FLAG;
	
	@Value("${UTENVCALS-INSPARAM-VALUE}")
	private String INSPARAM_VALUE;
	
    @Value("${UTENVCALS-DEF-RMODE}")
    private String dbmode;
	
    @Autowired
    @Qualifier("dayDataSource")
    private DataSource dayDataSource;
    
	  //START OF IR 25040080
    
	@Value("${UTENVCALS-MASTER-DB}")
	private String masterDB;
	
    @Autowired
    @Qualifier("nightDataSource")
    private DataSource nightDataSource;
	   //END OF CR 25040080 
//////////////////////////////////////////////////////////////////////////--------ENV VARIABLES ENDED--------\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

	Logger logger = LoggerFactory.getLogger(YONO_Enquiry_Service.class);
	
//////////////////////////////////////////////////////////////////////////--------PATH FILES READING STARTED--------\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
	
	String ErrorCodeMasterFilePath = CacheConfig.frameworkConfigProperties
			.getProperty(FrameworkConstants.LOOKUP_FILES_PATH);
	String sourceAuth = CacheConfig.frameworkConfigProperties.getProperty(FrameworkConstants.LOOKUP_FILES_PATH);
	String ipConfig = CacheConfig.frameworkConfigProperties.getProperty(FrameworkConstants.LOOKUP_FILES_PATH);
	Properties error = PropertyLoader
			.readPropertyFile(new String(ErrorCodeMasterFilePath + "/ErrorCodeMaster.properties"));
	Properties sId = PropertyLoader.readPropertyFile(new String(sourceAuth + "/SourceIdList.properties"));
	Properties ipprop = PropertyLoader.readPropertyFile(new String(ipConfig + "/IpConfigMaster.properties"));
	
//////////////////////////////////////////////////////////////////////////--------PATH FILES READING ENDED--------\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

	private final Response responseObj;

	@Autowired
	public YONO_Enquiry_Service(Response responseObj) {
		this.responseObj = responseObj;
	}
	
	@InitBinder
	public void initBinder(WebDataBinder binder) {
		binder.setDisallowedFields(new String[] {});
	}
	
    
//////////////////////////////////////////////////////////////////////////-------- OBJECTS CREATION STARTED--------\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
	
	
	ErrorResponse 			        errobj 		 = new ErrorResponse();
	Error_Description 		        errdesc 	 = new Error_Description();
	YONO_Child                      yonochild    = new YONO_Child();
	InputValidations_YONO           inpval 		 = new InputValidations_YONO();
	Gson gson = new Gson();
//////////////////////////////////////////////////////////////////////////-------- OBJECTS CREATION ENDED--------\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
	

	@SuppressWarnings({ "unchecked", "rawtypes"})
	@ApiOperation(value = "Call YONO", notes = "YONOEnq Service:This API is used to fetch Customer Details.")
	@PostMapping(value = { "/YONOEnq" }, produces = { "application/json" })
	@CrossOrigin()
	@JsonIgnoreProperties(ignoreUnknown = true)
	@Validated
	public ResponseEntity<Object> getCustomerDetails(@RequestBody(required = false) @Valid RequestBean_YONO reqbean,
			HttpServletRequest request, @RequestHeader HttpHeaders headers, HttpServletResponse response)
			throws Exception {

		response.setHeader("X-Content-Type-Options", "nosniff");
		response.setHeader("X-Frame-Options", "DENY");
		response.setHeader("Content-Security-Policy", "default-src 'self'");
		response.setHeader("X-XSS-Protection", "1;mode=block");
		
//////////////////////////////////////////////////////////////////////////-------- INITIAL VARIABLES--------\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
		
		String IPAddress = request.getHeader("X-Forwarded-For");
		String remoteAddress = request.getRemoteAddr();
		String accept = request.getHeader("Content-Type");
		DateTimeFormatter entryDate1 = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss:SSS");
		LocalDateTime time = LocalDateTime.now();
		String entryDate = entryDate1.format(time);
		
//////////////////////////////////////////////////////////////////////////-------- SERVICE VARIABLES--------\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
		String reqbeanstr = new String();
		String finalResponse = new String();
		String CIFRES_FILE_PATH = new String();
		String ACCRES_FILE_PATH = new String();
		String refno = new String();
		String tellerno = new String();
		String branchno = new String();
		String noOfRecords = new String();
		String cif_or_acct = new String();
		String option_flag = new String();
		String cifoutRes= new String();
		String accoutRes= new String();
		String errno = new String();
		String errDesc = new String();
		String sourceId  = new String();
		String validChkdFlag = new String();
		List<String> chkdRes = new ArrayList<>();
		String chkderr = new String();
		List<String> errList = new ArrayList<>();
		//START OF IR 25040080
//		DataSource dataSource 		 = getDataSource("day");
		DataSource dataSource 		 = dayDataSource;
		//END OF IR 25040080
		List<Telm> telm = new ArrayList<Telm>();
		List<Brhm> brhm = new ArrayList<Brhm>();
		List<Crdd> crdd = new ArrayList<Crdd>();
		String teller_identifier = new String();
		String formattedTeller = new String();
		String formattedBranch = new String();
		//START OF IR 25100006
		String formattedCardFileForCrdd =  new String();
		String formattedTellerForCrdd=  new String();
		String formatTellerRemoveZeros=  new String();	
		String sign_on_flag= new String();
		List<Ig01> signonDate = new ArrayList<Ig01>();
		String sigonTelmDate = new String();
		String stat = new String();
		String Ig01date = new String();
		//END OF IR 25100006
		
		
//////////////////////////////////////////////////////////////////////////-------- ENV VARIABLES--------\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
		
		String callcode = "S";
		String opt = "";
		List<String> res = new ArrayList<String>();
		String formattedmasterDB1 = StringUtils.rightPad(masterDB1, 15);
		String formattedmasterDB2 = StringUtils.rightPad(masterDB2, 15);
	
		String lsRecArea = bancsTraceState.trim() + masterDQType.trim() + bancsHost.trim() + fnsSysnum.trim()
		+ ctrlSysnum.trim() + daySysnum.trim() + nightSysnum.trim() + non24hsum.trim() + defRMode.trim()
		+ formattedmasterDB1 + formattedmasterDB2 + servicesFlag.trim() + masterDB.trim() + INSPARAM_FLAG.trim() + INSPARAM_VALUE.trim();
String[] arr = { bancsTraceState, masterDQType, bancsHost, fnsSysnum, ctrlSysnum, daySysnum, nightSysnum,
		non24hsum, defRMode, masterDB1, masterDB2, servicesFlag,masterDB, serviceid,CIF_RES_FILE_PATH,ACC_RES_FILE_PATH,ErrorCodeMasterFilePath, sourceAuth, ipConfig, INSPARAM_FLAG, INSPARAM_VALUE};
//END OF CR 25040080
		
//////////////////////////////////////////////////////////////////////////-------- INPUT VALIDATIONS--------\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
try {
	    if(reqbean != null) {
	    	if(!reqbean.isEmpty()){
	    		
	    		reqbeanstr = gson.toJson(reqbean).toString();
	    		
	    		tellerno   = reqbean.getTellerId();
	    		branchno   = reqbean.getBranchCode();	
	    	    refno	   =  reqbean.getReferenceNumber();
	    	    
		    
		    CIFRES_FILE_PATH = CIF_RES_FILE_PATH;
			ACCRES_FILE_PATH = ACC_RES_FILE_PATH;

		    errList = inpval.validateRefNum(refno);
		    errno = errList.get(1);
		    refno = errList.get(0);
		    if(!errno.equals("00000")) {			
				errDesc = error.getProperty(errno);			
					finalResponse = errobj.getErrorResponse(errno, errDesc, refno);
					migDetails.saveToLogDB(Base64.getEncoder().encodeToString((reqbeanstr.toString()).getBytes()), remoteAddress, tellerno, refno, sourceId, entryDate, IPAddress, errno, errDesc, "1", Base64.getEncoder().encodeToString((finalResponse).getBytes()), "failure" );
					return new ResponseEntity(finalResponse, HttpStatus.OK);
			}

			errList = inpval.validateTellerNum(tellerno);
		    errno = errList.get(1);
		    tellerno = errList.get(0);
			if (!errno.equals("00000"))
			{
				errDesc = error.getProperty(errno);	
					finalResponse = errobj.getErrorResponse(errno, errDesc, refno);
					migDetails.saveToLogDB(Base64.getEncoder().encodeToString((reqbeanstr.toString()).getBytes()), remoteAddress, tellerno, refno, sourceId, entryDate, IPAddress, errno, errDesc, "1", Base64.getEncoder().encodeToString((finalResponse).getBytes()), "failure" );
					return new ResponseEntity(finalResponse, HttpStatus.OK);
			}

			
			errList = inpval.validateBranchNum(branchno);
		    errno = errList.get(1);
		    branchno = errList.get(0);
			if (!errno.equals("00000")) 
			{

				errDesc = error.getProperty(errno);				
					finalResponse = errobj.getErrorResponse(errno, errDesc, refno);
					migDetails.saveToLogDB(Base64.getEncoder().encodeToString((reqbeanstr.toString()).getBytes()), remoteAddress, tellerno, refno, sourceId, entryDate, IPAddress, errno, errDesc, "1", Base64.getEncoder().encodeToString((finalResponse).getBytes()), "failure" );
					return new ResponseEntity(finalResponse, HttpStatus.OK);
			}

			cif_or_acct = reqbean.getcif_or_acct_number();
			chkdRes = inpval.validateCifOrAcctNumber(cif_or_acct);
			errno = chkdRes.get(1);
			if (!errno.equals("00000")) 
			{
				if (errno.equals("CB481")) 
				{
					errDesc = error.getProperty(errno);				
					finalResponse = errobj.getErrorResponse(errno, errDesc, refno);
					migDetails.saveToLogDB(Base64.getEncoder().encodeToString((reqbeanstr.toString()).getBytes()), remoteAddress, tellerno, refno, sourceId, entryDate, IPAddress, errno, errDesc, "1", Base64.getEncoder().encodeToString((finalResponse).getBytes()), "failure" );
					return new ResponseEntity(finalResponse, HttpStatus.OK);							
				} else {
					chkderr = errno;
					validChkdFlag = "N";
				}
			} else {
			   cif_or_acct = chkdRes.get(0);
				validChkdFlag = "Y";
			}
			
			option_flag = reqbean.getoptionflag();
			errList = inpval.Validate_Option_Flag(option_flag);
		    errno = errList.get(1);
		    option_flag = errList.get(0);
			if (!errno.equals("00000")) 
			{
				errDesc = error.getProperty(errno);				
		    		finalResponse = errobj.getErrorResponse(errno, errDesc, refno);
					migDetails.saveToLogDB(Base64.getEncoder().encodeToString((reqbeanstr.toString()).getBytes()), remoteAddress, tellerno, refno, sourceId, entryDate, IPAddress, errno, errDesc, "1", Base64.getEncoder().encodeToString((finalResponse).getBytes()), "failure" );
					return new ResponseEntity(finalResponse, HttpStatus.OK);			
			}
						
			logger.info("VC------------------------Initiating DB Pooling------------------------VC");
			
			if (accept != null && accept.contains("application/json")) {
				if (validChkdFlag.equals("Y")) {
						logger.info(
								"VC------------------------Intiating Teller&Branch Validation------------------------VC");
						ArrayList<Object> queryParamsTlr = new ArrayList<>();
						ArrayList<Object> queryParamsBrhm = new ArrayList<>();
						ArrayList<Object> queryParamsSignonDate = new ArrayList<>();
						ArrayList<Object> queryParamsCrddTeller = new ArrayList<>();
						queryParamsTlr.add("003");
						formattedTeller = StringUtils.leftPad(tellerno, 16, "0");
						queryParamsTlr.add(formattedTeller);
						
						formattedBranch = "003" + StringUtils.leftPad(branchno, 16, "0");
						queryParamsBrhm.add(formattedBranch);
						
						queryParamsSignonDate.add("000");
						
						//For CRDD Teller Check
						String tempString = "BYPASS_TLM.card";
						formattedCardFileForCrdd = String.format("%-30s",tempString );
					    formatTellerRemoveZeros = tellerno.replaceAll("^0+(?!$)", "");	
						formattedTellerForCrdd= String.format("%-299s", formatTellerRemoveZeros);
						
						
						queryParamsCrddTeller.add(formattedCardFileForCrdd);
						queryParamsCrddTeller.add(formattedTellerForCrdd);	
						
						try {
							// telm = dbProcess.fetchRepositories(null, "TELM", "TelmDetail", "findByTelmDetails", false,true, queryParamsTlr);
							crdd = dbProcess.fetchRepositories(null, "CRDD", "CrddDetail", "findByCrddDetails", false,true, queryParamsCrddTeller);
							brhm = dbProcess.fetchRepositories(null, "BRHM", "BrhmDetail", "findByBrhmDetails", false,true, queryParamsBrhm);
							//START OF IR 25100006
							signonDate = dbProcess.fetchRepositories(null, "IG01", "Ig01Detail", "findByIg01Details", false,true, queryParamsSignonDate);
					        DateTimeFormatter inputFormatter = DateTimeFormatter.ofPattern("yyyyMMdd");
					        DateTimeFormatter outputFormatter = DateTimeFormatter.ofPattern("ddMMyyyy");					       
					        LocalDate date = LocalDate.parse(signonDate.get(0).getCntldate(), inputFormatter);					       
					        String dateStringDDMMYYYY = date.format(outputFormatter);
					        Ig01date = dateStringDDMMYYYY;
					      //END OF IR 25100006
						} catch (Exception e1) {
							// TODO Auto-generated catch block
							logger.info("Exception Occured");
						}
				

	                    if (crdd != null && !crdd.isEmpty()) 
							{
							
								if(formatTellerRemoveZeros.equals(crdd.get(0).getVALUE().trim())) {
									
									logger.info("VC------------------------Virtual Teller Validated Sucessfully------------------------VC "+refno);
									
									if(brhm != null && !brhm.isEmpty()) {
									    logger.info(
									            "VC------------------------Virtual Teller & Branch Validated Sucessfully------------------------VC "+refno);	

																							    logger.info(
											            "VC------------------------Teller&Branch Validated Sucessfully------------------------VC");        							
												logger.info("VC------------------------Region Mode check started------------------------VC" + refno);
					    							List<Sysc> syscRes = new ArrayList<Sysc>();
					    							syscRes = syscReponight.findBySyscDetail();
					    							try {
					    								if (syscRes.get(0).getSyscVariable().substring(10, 11).equals("N")) {
					    									dataSource = nightDataSource;
					    									lsRecArea = bancsTraceState.trim() + 'N'+ bancsHost.trim() + fnsSysnum.trim()
					    									+ ctrlSysnum.trim() + daySysnum.trim() + nightSysnum.trim() + non24hsum.trim() + 'N'
					    									+ formattedmasterDB1 + formattedmasterDB2 + servicesFlag.trim() + masterDB.trim() + INSPARAM_FLAG.trim() + INSPARAM_VALUE.trim();
					    									logger.info("-----------REGION MODE IS NIGHT IN DATABASE - MODE SET TO NIGHT DB----------" + refno);
					    									}
					    								else if (syscRes.get(0).getSyscVariable().substring(10, 11).equals("D")){
					    									dataSource = dayDataSource;
					    									lsRecArea = bancsTraceState.trim() + 'D' + bancsHost.trim() + fnsSysnum.trim()
					    									+ ctrlSysnum.trim() + daySysnum.trim() + nightSysnum.trim() + non24hsum.trim() + 'D'
					    									+ formattedmasterDB1 + formattedmasterDB2 + servicesFlag.trim() + masterDB.trim() + INSPARAM_FLAG.trim() + INSPARAM_VALUE.trim();
					    									logger.info("-----------REGION MODE IS DAY IN DATABASE - MODE SET TO DAY DB----------" + refno);
					    									}
					    								else {
					    									dataSource = nightDataSource;
					    									lsRecArea = bancsTraceState.trim() + 'N'+ bancsHost.trim() + fnsSysnum.trim()
					    									+ ctrlSysnum.trim() + daySysnum.trim() + nightSysnum.trim() + non24hsum.trim() + 'N'
					    									+ formattedmasterDB1 + formattedmasterDB2 + servicesFlag.trim() + masterDB.trim() + INSPARAM_FLAG.trim() + INSPARAM_VALUE.trim();
					    									
					    									logger.info("-----------REGION MODE IS INVALID IN DATABASE - MODE SET TO NIGHT DB----------" + refno);
					    									}
					    								} catch(Exception e) {
					    									dataSource = nightDataSource;
					    									lsRecArea = bancsTraceState.trim() + 'N'+ bancsHost.trim() + fnsSysnum.trim()
					    									+ ctrlSysnum.trim() + daySysnum.trim() + nightSysnum.trim() + non24hsum.trim() + 'N'
					    									+ formattedmasterDB1 + formattedmasterDB2 + servicesFlag.trim() + masterDB.trim() + INSPARAM_FLAG.trim() + INSPARAM_VALUE.trim();
					    									
					    									logger.info("-----------NO SYSC ENTRY IN DATABASE - MODE SET TO NIGHT DB----------" + refno);
					    								}	

					    							logger.info(
																"VC------------------------Region Mode check ended------------------------VC" + refno);
					    				
											    	res = yonochild.callYONOEnquiryChild(branchno, tellerno, cif_or_acct, option_flag, dataSource, lsRecArea);
											    	cifoutRes = res.get(0);									
													accoutRes = res.get(1);
													noOfRecords = res.get(2);
													logger.info("VC------------------------Fetched NO_OF_RECORDS------------------------VC" + noOfRecords);
													errno = res.get(3);
													logger.info("VC------------------------Fetched ERROR_NUMBER------------------------VC" + errno);
												
												
						

							
							}
						
								else {
									logger.info("VC--------------INVALID BRANCH NUMBER--------------VC "+refno);
									errno = "0526";
									errDesc = error.getProperty(errno);
									finalResponse = errobj.getErrorResponse(errno, errDesc, refno);
									migDetails.saveToLogDB(Base64.getEncoder().encodeToString((reqbeanstr.toString()).getBytes()), remoteAddress, tellerno, refno, sourceId, entryDate, IPAddress, errno, errDesc, "1", Base64.getEncoder().encodeToString((finalResponse).getBytes()), "failure" );								
									return new ResponseEntity(finalResponse, HttpStatus.OK);
								}
							
									
									
								}
								else {
									logger.info("VC--------------USER NOT SIGNED ON--------------VC "+refno);
									errno = "0148";
									errDesc = error.getProperty(errno);
									finalResponse = errobj.getErrorResponse(errno, errDesc, refno);
									migDetails.saveToLogDB(Base64.getEncoder().encodeToString((reqbeanstr.toString()).getBytes()), remoteAddress, tellerno, refno, sourceId, entryDate, IPAddress, errno, errDesc, "1", Base64.getEncoder().encodeToString((finalResponse).getBytes()), "failure" );
									return new ResponseEntity(finalResponse, HttpStatus.OK);
								}
								
							}
							
							else{
							

							try {
								telm = dbProcess.fetchRepositories(null, "TELM", "TelmDetail", "findByTelmDetails", false,true, queryParamsTlr);
								signonDate = dbProcess.fetchRepositories(null, "IG01", "Ig01Detail", "findByIg01Details", false,true, queryParamsSignonDate);
						        DateTimeFormatter inputFormatter = DateTimeFormatter.ofPattern("yyyyMMdd");
						        LocalDate date = LocalDate.parse(signonDate.get(0).getCntldate(), inputFormatter);
						        DateTimeFormatter outputFormatter = DateTimeFormatter.ofPattern("ddMMyyyy");
						        String ddmmyyyy = date.format(outputFormatter);			        
						        Ig01date = ddmmyyyy;
							} catch (Exception e) {
								logger.info("Exception Occured at TELM " + refno );
							}
							
							if(telm != null && !telm.isEmpty()) {
								sign_on_flag=telm.get(0).getSIGNON_FLAG(); 
								teller_identifier = telm.get(0).getTELLER_IDENTIFIER();
								sigonTelmDate = telm.get(0).getSIGN_ON_DATE();
								stat = telm.get(0).getSTAT();
								if("Y".equals(teller_identifier)) {
									if(brhm != null && !brhm.isEmpty()) {
									    logger.info(
									            "VC------------------------Virtual Teller Based On Teller Identifier & Branch Validated Sucessfully------------------------VC "+refno);	
												
									    logger.info(
						            "VC------------------------Teller&Branch Validated Sucessfully------------------------VC");  
						  //START OF IR 25040080        							
							logger.info("VC------------------------Region Mode check started------------------------VC" + refno);
    							List<Sysc> syscRes = new ArrayList<Sysc>();
    							syscRes = syscReponight.findBySyscDetail();

    							try {
    								if (syscRes.get(0).getSyscVariable().substring(10, 11).equals("N")) {
    									dataSource = nightDataSource;
    									lsRecArea = bancsTraceState.trim() + 'N'+ bancsHost.trim() + fnsSysnum.trim()
    									+ ctrlSysnum.trim() + daySysnum.trim() + nightSysnum.trim() + non24hsum.trim() + 'N'
    									+ formattedmasterDB1 + formattedmasterDB2 + servicesFlag.trim() + masterDB.trim() + INSPARAM_FLAG.trim() + INSPARAM_VALUE.trim();
    									logger.info("-----------REGION MODE IS NIGHT IN DATABASE - MODE SET TO NIGHT DB----------" + refno);
    									}
    								else if (syscRes.get(0).getSyscVariable().substring(10, 11).equals("D")){
    									dataSource = dayDataSource;
    									lsRecArea = bancsTraceState.trim() + 'D' + bancsHost.trim() + fnsSysnum.trim()
    									+ ctrlSysnum.trim() + daySysnum.trim() + nightSysnum.trim() + non24hsum.trim() + 'D'
    									+ formattedmasterDB1 + formattedmasterDB2 + servicesFlag.trim() + masterDB.trim() + INSPARAM_FLAG.trim() + INSPARAM_VALUE.trim();
    									logger.info("-----------REGION MODE IS DAY IN DATABASE - MODE SET TO DAY DB----------" + refno);
    									}
    								else {
    									dataSource = nightDataSource;
    									lsRecArea = bancsTraceState.trim() + 'N'+ bancsHost.trim() + fnsSysnum.trim()
    									+ ctrlSysnum.trim() + daySysnum.trim() + nightSysnum.trim() + non24hsum.trim() + 'N'
    									+ formattedmasterDB1 + formattedmasterDB2 + servicesFlag.trim() + masterDB.trim() + INSPARAM_FLAG.trim() + INSPARAM_VALUE.trim();
    									
    									logger.info("-----------REGION MODE IS INVALID IN DATABASE - MODE SET TO NIGHT DB----------" + refno);
    									}
    								} catch(Exception e) {
    									dataSource = nightDataSource;
    									lsRecArea = bancsTraceState.trim() + 'N'+ bancsHost.trim() + fnsSysnum.trim()
    									+ ctrlSysnum.trim() + daySysnum.trim() + nightSysnum.trim() + non24hsum.trim() + 'N'
    									+ formattedmasterDB1 + formattedmasterDB2 + servicesFlag.trim() + masterDB.trim() + INSPARAM_FLAG.trim() + INSPARAM_VALUE.trim();
    									
    									logger.info("-----------NO SYSC ENTRY IN DATABASE - MODE SET TO NIGHT DB----------" + refno);
    								}
    							//End of IR 25090016	

    							logger.info(
											"VC------------------------Region Mode check ended------------------------VC" + refno);
    							//END OF IR 25040080  
						    	res = yonochild.callYONOEnquiryChild(branchno, tellerno, cif_or_acct, option_flag, dataSource, lsRecArea);
						    	cifoutRes = res.get(0);									
								accoutRes = res.get(1);
								noOfRecords = res.get(2);
								logger.info("VC------------------------Fetched NO_OF_RECORDS------------------------VC" + noOfRecords);
								errno = res.get(3);
								logger.info("VC------------------------Fetched ERROR_NUMBER------------------------VC" + errno);			
						
									   
							}
						
								else {
									logger.info("VC--------------INVALID BRANCH NUMBER--------------VC "+refno);
									errno = "0526";
									errDesc = error.getProperty(errno);
									finalResponse = errobj.getErrorResponse(errno, errDesc, refno);
									migDetails.saveToLogDB(Base64.getEncoder().encodeToString((reqbeanstr.toString()).getBytes()), remoteAddress, tellerno, refno, sourceId, entryDate, IPAddress, errno, errDesc, "1", Base64.getEncoder().encodeToString((finalResponse).getBytes()), "failure" );								
									return new ResponseEntity(finalResponse, HttpStatus.OK);
								}
							}
								
								else if("Y".equals(sign_on_flag)&& "01".equals(stat)  && Objects.equals(sigonTelmDate, Ig01date))
								{
									if(brhm != null && !brhm.isEmpty()) {
									    logger.info(
									            "VC------------------------Teller & Branch Validated Sucessfully------------------------VC "+refno);
												
												
												    logger.info(
								            "VC------------------------Teller&Branch Validated Sucessfully------------------------VC");        							
									logger.info("VC------------------------Region Mode check started------------------------VC" + refno);
		    							List<Sysc> syscRes = new ArrayList<Sysc>();
		    							syscRes = syscReponight.findBySyscDetail();
		    							try {
		    								if (syscRes.get(0).getSyscVariable().substring(10, 11).equals("N")) {
		    									dataSource = nightDataSource;
		    									lsRecArea = bancsTraceState.trim() + 'N'+ bancsHost.trim() + fnsSysnum.trim()
		    									+ ctrlSysnum.trim() + daySysnum.trim() + nightSysnum.trim() + non24hsum.trim() + 'N'
		    									+ formattedmasterDB1 + formattedmasterDB2 + servicesFlag.trim() + masterDB.trim() + INSPARAM_FLAG.trim() + INSPARAM_VALUE.trim();
		    									logger.info("-----------REGION MODE IS NIGHT IN DATABASE - MODE SET TO NIGHT DB----------" + refno);
		    									}
		    								else if (syscRes.get(0).getSyscVariable().substring(10, 11).equals("D")){
		    									dataSource = dayDataSource;
		    									lsRecArea = bancsTraceState.trim() + 'D' + bancsHost.trim() + fnsSysnum.trim()
		    									+ ctrlSysnum.trim() + daySysnum.trim() + nightSysnum.trim() + non24hsum.trim() + 'D'
		    									+ formattedmasterDB1 + formattedmasterDB2 + servicesFlag.trim() + masterDB.trim() + INSPARAM_FLAG.trim() + INSPARAM_VALUE.trim();
		    									logger.info("-----------REGION MODE IS DAY IN DATABASE - MODE SET TO DAY DB----------" + refno);
		    									}
		    								else {
		    									dataSource = nightDataSource;
		    									lsRecArea = bancsTraceState.trim() + 'N'+ bancsHost.trim() + fnsSysnum.trim()
		    									+ ctrlSysnum.trim() + daySysnum.trim() + nightSysnum.trim() + non24hsum.trim() + 'N'
		    									+ formattedmasterDB1 + formattedmasterDB2 + servicesFlag.trim() + masterDB.trim() + INSPARAM_FLAG.trim() + INSPARAM_VALUE.trim();
		    									
		    									logger.info("-----------REGION MODE IS INVALID IN DATABASE - MODE SET TO NIGHT DB----------" + refno);
		    									}
		    								} catch(Exception e) {
		    									dataSource = nightDataSource;
		    									lsRecArea = bancsTraceState.trim() + 'N'+ bancsHost.trim() + fnsSysnum.trim()
		    									+ ctrlSysnum.trim() + daySysnum.trim() + nightSysnum.trim() + non24hsum.trim() + 'N'
		    									+ formattedmasterDB1 + formattedmasterDB2 + servicesFlag.trim() + masterDB.trim() + INSPARAM_FLAG.trim() + INSPARAM_VALUE.trim();
		    									
		    									logger.info("-----------NO SYSC ENTRY IN DATABASE - MODE SET TO NIGHT DB----------" + refno);
		    								}	

		    							logger.info(
													"VC------------------------Region Mode check ended------------------------VC" + refno);
		    				
								    	res = yonochild.callYONOEnquiryChild(branchno, tellerno, cif_or_acct, option_flag, dataSource, lsRecArea);
								    	cifoutRes = res.get(0);									
										accoutRes = res.get(1);
										noOfRecords = res.get(2);
										logger.info("VC------------------------Fetched NO_OF_RECORDS------------------------VC" + noOfRecords);
										errno = res.get(3);
										logger.info("VC------------------------Fetched ERROR_NUMBER------------------------VC" + errno);
						
									  
								}
									else {
										logger.info("VC--------------INVALID BRANCH NUMBER--------------VC "+refno);
										errno = "0526";
										errDesc = error.getProperty(errno);
										finalResponse = errobj.getErrorResponse(errno, errDesc, refno);
										migDetails.saveToLogDB(Base64.getEncoder().encodeToString((reqbeanstr.toString()).getBytes()), remoteAddress, tellerno, refno, sourceId, entryDate, IPAddress, errno, errDesc, "1", Base64.getEncoder().encodeToString((finalResponse).getBytes()), "failure" );								
										return new ResponseEntity(finalResponse, HttpStatus.OK);
									}
									
								}
								
									
									
							else {
								logger.info("VC--------------USER NOT SIGNED ON--------------VC "+refno);
								errno = "0148";
								errDesc = error.getProperty(errno);
								finalResponse = errobj.getErrorResponse(errno, errDesc, refno);
								migDetails.saveToLogDB(Base64.getEncoder().encodeToString((reqbeanstr.toString()).getBytes()), remoteAddress, tellerno, refno, sourceId, entryDate, IPAddress, errno, errDesc, "1", Base64.getEncoder().encodeToString((finalResponse).getBytes()), "failure" );
								return new ResponseEntity(finalResponse, HttpStatus.OK);
							}
						}
							
							else {
								logger.info("VC--------------INVALID TELLER NUMBER--------------VC "+refno);
								errno = "0529";
								errDesc = error.getProperty(errno);
								finalResponse = errobj.getErrorResponse(errno, errDesc, refno);
								migDetails.saveToLogDB(Base64.getEncoder().encodeToString((reqbeanstr.toString()).getBytes()), remoteAddress, tellerno, refno, sourceId, entryDate, IPAddress, errno, errDesc, "1", Base64.getEncoder().encodeToString((finalResponse).getBytes()), "failure" );
								return new ResponseEntity(finalResponse, HttpStatus.OK);
							}
							
						}					  
						
					
					}
					else {
						errno = chkderr;
						try(Connection connection = dataSource.getConnection()) {	
						errDesc = errdesc.getCbsErrDesc(chkderr, callcode, opt, lsRecArea, connection);
						} catch(SQLException e) {
							errno = "3293";
						    errDesc= error.getProperty(errno);						
								finalResponse = errobj.getErrorResponse(errno, errDesc, refno);
								migDetails.saveToLogDB(Base64.getEncoder().encodeToString((reqbeanstr.toString()).getBytes()), remoteAddress, tellerno, refno, sourceId, entryDate, IPAddress, errno, errDesc, "1", Base64.getEncoder().encodeToString((finalResponse).getBytes()), "failure" );
								return new ResponseEntity(finalResponse, HttpStatus.OK);
				         }
						finalResponse = errobj.getErrorResponse(chkderr, errDesc, refno);
						migDetails.saveToLogDB(Base64.getEncoder().encodeToString((reqbeanstr.toString()).getBytes()), remoteAddress, tellerno, refno, sourceId, entryDate, IPAddress, errno, errDesc, "1", Base64.getEncoder().encodeToString((finalResponse).getBytes()), "failure" );
						return new ResponseEntity(finalResponse, HttpStatus.OK);
					}				
			}
			else {
				errno = "0435";
			    errDesc= error.getProperty(errno);
				finalResponse = errobj.getErrorResponse(errno, errDesc, refno);
				migDetails.saveToLogDB(Base64.getEncoder().encodeToString((reqbeanstr.toString()).getBytes()), remoteAddress, tellerno, refno, sourceId, entryDate, IPAddress, errno, errDesc, "1", Base64.getEncoder().encodeToString((finalResponse).getBytes()), "failure" );
				return new ResponseEntity(finalResponse, HttpStatus.OK);		
			}
		}
			else {
				errno = "CB422";
			    errDesc= error.getProperty(errno);
					finalResponse = errobj.getErrorResponse(errno, errDesc, refno);
					migDetails.saveToLogDB(Base64.getEncoder().encodeToString((" ".toString()).getBytes()), remoteAddress, tellerno, refno, sourceId, entryDate, IPAddress, errno, errDesc, "1", Base64.getEncoder().encodeToString((finalResponse).getBytes()), "failure" );
					return new ResponseEntity(finalResponse, HttpStatus.OK);
			}  
	    }

	    else {
	    	errno = "CB422";
		    errDesc= error.getProperty(errno);
				finalResponse = errobj.getErrorResponse(errno, errDesc, refno);
				migDetails.saveToLogDB(Base64.getEncoder().encodeToString((" ".toString()).getBytes()), remoteAddress, tellerno, refno, sourceId, entryDate, IPAddress, errno, errDesc, "1", Base64.getEncoder().encodeToString((finalResponse).getBytes()), "failure" );
				return new ResponseEntity(finalResponse, HttpStatus.OK);
	    }
	    
	    //Response from service
	    if (errno.equals("0000")) {
			errno = "";
			finalResponse = responseObj.getResponse(CIFRES_FILE_PATH, ACCRES_FILE_PATH, cifoutRes, accoutRes, refno, noOfRecords);
			migDetails.saveToLogDB(Base64.getEncoder().encodeToString((reqbeanstr.toString()).getBytes()), remoteAddress, tellerno, refno, sourceId, entryDate, IPAddress, errno, errDesc, "0", Base64.getEncoder().encodeToString((finalResponse).getBytes()), "success" );
		} else if(errno.equals("3293")) {
			errDesc = error.getProperty(errno);
				finalResponse = errobj.getErrorResponse(errno, errDesc, refno);
				migDetails.saveToLogDB(Base64.getEncoder().encodeToString((reqbeanstr.toString()).getBytes()), remoteAddress, tellerno, refno, sourceId, entryDate, IPAddress, errno, errDesc, "1", Base64.getEncoder().encodeToString((finalResponse).getBytes()), "failure" );
				return new ResponseEntity(finalResponse, HttpStatus.OK);				
		}
	    else {
			try(Connection connection = dataSource.getConnection()) {
			errDesc = errdesc.getCbsErrDesc(errno, callcode, opt, lsRecArea, connection);
			} catch(SQLException e) {			
				errno = "3293";					
				errDesc = error.getProperty(errno);				
					finalResponse = errobj.getErrorResponse(errno, errDesc, refno);
					migDetails.saveToLogDB(Base64.getEncoder().encodeToString((reqbeanstr.toString()).getBytes()), remoteAddress, tellerno, refno, sourceId, entryDate, IPAddress, errno, errDesc, "1", Base64.getEncoder().encodeToString((finalResponse).getBytes()), "failure" );
					return new ResponseEntity(finalResponse, HttpStatus.OK);
			}
			finalResponse = errobj.getErrorResponse(errno, errDesc, refno);
			migDetails.saveToLogDB(Base64.getEncoder().encodeToString((reqbeanstr.toString()).getBytes()), remoteAddress, tellerno, refno, sourceId, entryDate, IPAddress, errno, errDesc, "1", Base64.getEncoder().encodeToString((finalResponse).getBytes()), "failure" );
		}
		return new ResponseEntity(finalResponse, HttpStatus.OK);
}
catch(Exception  ex) {
	logger.info(" EXCEPTION OCCURED IN 	YONO ENQUIRY " +  refno);
	errno = "0155";
	errDesc = error.getProperty(errno);
	finalResponse = errobj.getErrorResponse(errno, errDesc, refno);	
	migDetails.saveToLogDB(Base64.getEncoder().encodeToString((" ".toString()).getBytes()), remoteAddress, tellerno, refno, sourceId, entryDate, IPAddress, errno, errDesc, "1", Base64.getEncoder().encodeToString((finalResponse).getBytes()), "failure" );
	return new ResponseEntity(finalResponse, HttpStatus.OK);

} 
}  
	}...



@Configuration
@PropertySource({"file:${ChannelsPropConfigPath}/Config/DBProperties.properties"})
@ConditionalOnProperty(value = {"prnight.module.enabled"}, havingValue = "true", matchIfMissing = true)
@EnableTransactionManagement
@EnableMBeanExport(registration = RegistrationPolicy.IGNORE_EXISTING)
@EnableJpaRepositories(entityManagerFactoryRef = "prnightEntityManagerFactory", transactionManagerRef = "prnightTransactionManager", basePackages = {"com.tcs.bancs.microservices.repository.night"})
public class CBSPRNightDbConfig
{
public static Set<Class<? extends Object>> nightClasses = null;

@Value("${prnight.jpa.properties.hibernate.dialect:com.tcs.bancs.microservices.configuration.CustomOracleDialect}")
private String hibernateDialect;

//@Value("${prnight.datasource.hikari.maximum-pool-size}")
//private int maxPoolSize;
//
//@Value("${prnight.datasource.hikari.minimum-idle}")
//private int minIdle;
@Value("${prnight.datasource.hikari.pool-name}")
private String poolName;
@Value("${prnight.datasource.hikari.connectionTimeout}")
private long connectionTimeout;
@Value("${prnight.datasource.hikari.idleTimeout}")
private long idleTimeout;
@Value("${prnight.datasource.hikari.maxLifetime}")
private long maxLifetime;
@Value("${prnight.datasource.hikari.registerMbeans}")
private boolean registerMbeans;

@Lazy
@Bean(name = {"prnightDataSource"})
@ConfigurationProperties(prefix = "prnight.datasource")
public HikariDataSource nightdataSource() {
HikariDataSource dataSource = (HikariDataSource)DataSourceBuilder.create().type(HikariDataSource.class).build();
	//HikariDataSource dataSource = new 	HikariDataSource();
//dataSource.setMaximumPoolSize(this.maxPoolSize);
//dataSource.setMinimumIdle(this.minIdle);
dataSource.setPoolName(this.poolName);
dataSource.setConnectionTimeout(this.connectionTimeout);
dataSource.setIdleTimeout(this.idleTimeout);
dataSource.setMaxLifetime(this.maxLifetime);
dataSource.setRegisterMbeans(this.registerMbeans);
return dataSource;
}



@Bean(name = {"prnightTransactionManager"})
public PlatformTransactionManager prnightTransactionManager(@Qualifier("prnightEntityManagerFactory") EntityManagerFactory prnightEntityManagerFactory) {
return (PlatformTransactionManager)new JpaTransactionManager(prnightEntityManagerFactory);
}



@Bean(name = {"prnightEntityManagerFactory"})
public LocalContainerEntityManagerFactoryBean prnightEntityManagerFactory(EntityManagerFactoryBuilder builder, @Qualifier("prnightDataSource") DataSource dataSource) {
HashMap<String, Object> props = new HashMap<>();
props.put("hibernate.dialect", this.hibernateDialect);

return builder.dataSource(dataSource).properties(props).packages(new String[] { "com.tcs.bancs.microservices.db.model"
}).persistenceUnit("prnight").build();
}
}
@SpringBootApplication(exclude = { DataSourceAutoConfiguration.class, // HibernateJpaAutoConfiguration.class,
		DataSourceTransactionManagerAutoConfiguration.class }, scanBasePackages = "com.tcs.bancs.microservices")
@ComponentScan(basePackages = { "com.tcs.bancs.microservices", "com.tcs.bancs.microservices.config",
		"com.tcs.bancs.api", "com.tcs.bancs.microservices.interceptor", "com.tcs.bancs.microservices.api",
		"com.tcs.bancs.microservices.model", "com.tcs.bancs.microservices.util", "com.tcs.bancs.microservices",
		"com.tcs.bancs.microservices.impl", "com.tcs.bancs.microservices.repository.day",
		"com.tcs.bancs.microservices.repository.night", "com.tcs.bancs.microservices.repository.ref",
		"com.tcs.bancs.microservices.exception", "com.tcs.bancs.microservices.mappings",
		"com.tcs.bancs.microservices.model" })
@EnableSwagger2
@Import({ CBSDayDbConfig.class, CBSNightDbConfig.class, CBSRefDbConfig.class })
public class OpenBankingServicesApp extends SpringBootServletInitializer {
	private static Logger LOGGER = LoggerFactory.getLogger(OpenBankingServicesApp.class);

	public static void main(String[] args) {

		if (System.getProperty("ChannelsPropConfigPath") == null) {
			LOGGER.info(
					"Path to config property file is not set! Please set the system variable \"ChannelsPropConfigPath\" with the path to the config file.");
			LOGGER.info("Execution Finished with Error!");
		}

		SpringApplication.run(OpenBankingServicesApp.class, args);

	}
