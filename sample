Checklist for coding
Ingress URL of a service-
-	Use lower case
-	Use hyphen(-) if necessary
-	Don’t use camel case, all upper case, only numerical
Jar Naming convention –
-	Use Lower case
-	Don’t use camel case, all upper case, only numerical, special characters.
Name of the ingress and jar must be same.
The main service class must contain only framework related code and call to child classes.
Create child classes for calling JVM COBOL classes.
Maintain packages for each category.
Declare objects in global scope – for java classes
Declare objects in local scope – for JVM COBOL classes
Don’t declare of variables in global scope
Don’t use ‘==’ operator for string comparisons
Initialization of string variables
Input validations must have check for null, empty, spaces, length, and mandatory/non - mandatory.
Don’t manipulate the value received from web layer
If manipulation is needed do it after initial validations or at the time of function call.
Create the request bean class based on SD.
All the request parameters must be added in the isEmpty() method of Request Bean Class
When using a parameter from properties file –
-	make sure to have an entry for the field in properties file
-	Same naming convention must be used in code as well as in file.
Addition of newly introduced parameters of properties file in code –
-	Add the variable to array which is used for initial validations
-	Append the values to variable which is used to set environment
CBS error number should be 4 digits, add zeros at begin wherever applicable
The naming convention of the fields must be updated in Response and error response class as per SD
The data given in response and data in LOG DB must match
Update the value of TXN_NAME, TXN_NO fields of LOG DB table according to the service in the related code
All the commits to LOG DB after initial save must use update method.
Close the resources which are opened
Use try catch around getConnection() method
Use logger statements efficiently
Don’t print any user information inside logger.
Run unit - 
-	The data type of the connection string in JVM COBOL must be SQL data type
-	It must be the last variable in linkage section
-	Pass using BY VALUE
-	getReference() will be show warning in the editor, ignore it

Checklist for creation jar
Ensure there are no problems in the workspace
The service must be down before creation of jar
Addition of cbldat files
Don’t change the folder or file names once the jar has been created.
No addition/removal/rename of jars in the dependency lib after jar creation.

Checklist before the deployment
Maintain versioning of all check-ins in the below mentioned path
Path : \\10.243.6.40\Visual Cobol Microservices Checkin
config.properties and application.properties must have relative paths of the files.
application.properties must contain parameterized version of DB logins.
application.properties must contain the DB parameters set for DB Pooling(thread life time, thread count etc)
Response outline of the service must be placed inside JsonAta folder.
Modify Banner.txt particular to the service.
In DBProperties file, the value of day and ref mode fields must be set to true.
Make sure old jars to be removed and replace it with new one.
Checklist for CR
Feasibility submission – 1-2 days.
Development should not take more than 5 days.
Prepare unit test cases for framework and services
Initial testing using Dev DB data
Once the code is almost finalized, testing should be done on ST DB data
While testing on ST DB data, start internal review (JAVA, COBOL) in parallel.
If all the test cases are passed on ST data and internal review (JAVA, COBOL) done, then go for CHECK-IN/ HP FORTIFY SCAN
WBT should be prepared with DEV DB data.
While promoting CR to ST, if vulnerabilities are raised go with no observations mail from ISD. DGM approval for suppression will be provided at UAT promotion level.
Whenever any new concept is being introduced or changes in framework, deploy and test it on DEV region and then go for ST deployment.
While redeploying a service, don’t modify existing check-in version, and create the next version. [Even for a minor change]
Once the CR is in ST, start gathering data for UAT and test for the same.
Once you get ST PASS, do load testing on ST region and store reports in the below path
	Path: \\10.243.6.40\Visual Cobol Microservices Load Report

NOTE: Don’t manipulate the check-in folders in the path.














package com.tcs.bancs.microservices.service;
import com.tcs.bancs.microservices.enc.utils.SBISFTP;
import java.io.IOException;
import java.io.PrintStream;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.util.Scanner;
import javax.crypto.BadPaddingException;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
public class DecryptionResponse
{
  static String encResponse = new String();
  public static void main(String[] args)
  {
    Scanner sc = new Scanner(System.in);
    System.out.print("Enter AES Key=");
    String accessToken = sc.nextLine();
    System.out.print("\nEnter Encrypted Response file path=\n");
    String encResponsepath = sc.nextLine();
    
    try {
        Files.lines(Paths.get(encResponsepath)).forEach(line -> {
            encResponse += line;            
        });
    } catch (IOException e) {
        System.out.println("Error occurred while fetching the encrypted response file");
    }
        
    try
    {
      String decResponse = SBISFTP.decryptResponse(accessToken, encResponse);
      System.out.println("Decrypted Response>>\n" + decResponse);
    }
    catch (java.security.NoSuchAlgorithmException | InvalidKeyException | NoSuchPaddingException | InvalidAlgorithmParameterException | IllegalStateException | IllegalBlockSizeException | BadPaddingException | IOException e)
    {
      e.printStackTrace();
    }
  }
}
⭐
package com.tcs.bancs.microservices.service;

import com.tcs.bancs.microservices.enc.utils.SBISFTP;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.util.Scanner;
import javax.crypto.BadPaddingException;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;

public class DecryptionResponse {
    public static void main(String[] args) {
        try (Scanner sc = new Scanner(System.in)) {
            // Take AES Key from user
            System.out.print("Enter AES Key: ");
            String accessToken = sc.nextLine();

            // Take Encrypted Response File Path
            System.out.print("\nEnter Encrypted Response file path: ");
            String encResponsePath = sc.nextLine();

            // Read file content into StringBuilder
            StringBuilder encResponse = new StringBuilder();
            try {
                Files.lines(Paths.get(encResponsePath)).forEach(encResponse::append);
            } catch (IOException e) {
                System.err.println("Error occurred while fetching the encrypted response file.");
                e.printStackTrace();
                return;
            }

            // Decrypt the response
            try {
                String decResponse = SBISFTP.decryptResponse(accessToken, encResponse.toString());
                System.out.println("Decrypted Response:\n" + decResponse);
            } catch (java.security.NoSuchAlgorithmException | InvalidKeyException | NoSuchPaddingException |
                     InvalidAlgorithmParameterException | IllegalStateException | IllegalBlockSizeException |
                     BadPaddingException | IOException e) {
                System.err.println("Error occurred while decrypting the response.");
                e.printStackTrace();
            }
        }
    }
}




//    SBI Core Banking Project, Kondapur, Hyderabad, India.       *
//*****************************************************************
//                                                                *
//  	           PROGRAM - OpenBankingServicesApp.Java                *
//                                                                *
//*****************************************************************
//                 P R O G R A M    H I S T O R Y                 *
//                                                                *
//   PROGRAMMER    :    DATE       :  SPR NO   :   COMMENTS       *
//----------------------------------------------------------------*
// Naga Sai Ganesh : 15/10/2024    : 24090001  :  MICROSERVICES   *
// Niharika Tammana: 15/10/2024    : 24090001  :  MICROSERVICES   *
//----------------------------------------------------------------*

package com.tcs.bancs.microservices;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration;
import org.springframework.boot.builder.SpringApplicationBuilder;
import org.springframework.boot.web.servlet.support.SpringBootServletInitializer;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Import;
//import org.springframework.data.jpa.repository.config.EnableJpaRepositories;

import com.tcs.bancs.microservices.config.CBSDayDbConfig;
import com.tcs.bancs.microservices.config.CBSNightDbConfig;
import com.tcs.bancs.microservices.config.CBSRefDbConfig;
import springfox.documentation.swagger2.annotations.EnableSwagger2;

@SpringBootApplication(exclude = { DataSourceAutoConfiguration.class, // HibernateJpaAutoConfiguration.class,
		DataSourceTransactionManagerAutoConfiguration.class }, scanBasePackages = "com.tcs.bancs.microservices")
@ComponentScan(basePackages = { "com.tcs.bancs.microservices", "com.tcs.bancs.microservices.config",
		"com.tcs.bancs.api", "com.tcs.bancs.microservices.interceptor", "com.tcs.bancs.microservices.api",
		"com.tcs.bancs.microservices.model", "com.tcs.bancs.microservices.util", "com.tcs.bancs.microservices",
		"com.tcs.bancs.microservices.impl", "com.tcs.bancs.microservices.repository.day",
		"com.tcs.bancs.microservices.repository.night", "com.tcs.bancs.microservices.repository.ref",
		"com.tcs.bancs.microservices.exception", "com.tcs.bancs.microservices.mappings",
		"com.tcs.bancs.microservices.model" })
@EnableSwagger2
@Import({ CBSDayDbConfig.class, CBSNightDbConfig.class, CBSRefDbConfig.class })
public class OpenBankingServicesApp extends SpringBootServletInitializer {
	private static Logger LOGGER = LoggerFactory.getLogger(OpenBankingServicesApp.class);

	public static void main(String[] args) {

		if (System.getProperty("ChannelsPropConfigPath") == null) {
			LOGGER.info(
					"Path to config property file is not set! Please set the system variable \"ChannelsPropConfigPath\" with the path to the config file.");
			LOGGER.info("Execution Finished with Error!");
		}

		SpringApplication.run(OpenBankingServicesApp.class, args);

	}
	
	
	protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {
		return builder.sources(OpenBankingServicesApp.class);
	}

}


public class Main {
    public static void main(String[] args) {
        String decResponse = "123,456,789{abc,def},[1,000,2,000],xyz";
        
        // Split the string while preserving commas between numbers
        // Use negative lookahead (?![0-9]) and negative lookbehind (?<![0-9]) to avoid splitting on commas between digits
        String[] parts = decResponse.split(",(?![0-9])|(?<![0-9]),|[\\{\\}\\[\\]]+");
        
        // Print the result
        for (String part : parts) {
            System.out.println(part);
        }
    }
}


if (StringUtils.isAlpha(opcode)) {
				if (opcode.equals("F") || opcode.equals("M") || opcode.equals("P") || opcode.equals("E")) {






 RunUnit run1 = new RunUnit();
		 try (Connection connection = datasource.getConnection()){
			
	            run1.Add(jvm60457);
 	    		run1.Call("JVM60457", cif_number.get_Reference(), opt_flag.get_Reference(), branch_num.get_Reference(), teller_num.get_Reference(), out_cif_details.get_Reference(), out_account_array.get_Reference(),  out_error_num.get_Reference(), Rec_Area.get_Reference(),connection);
 	    		errno = out_error_num.getJvmOutErrorNo();
		 } catch (SQLException e) {
			 errno = "3293";

		}
		 
			 cif_details = out_cif_details.getJvmOutCifDetails();
			index = 0;
			while (index <= 9999) {
				String account_details = out_account_array.getJvmOutput60457Output(index);
				if (!account_details.trim().isEmpty()) {
					Output_Acc = Output_Acc + account_details;
					index+=1;
				}
				else {
					break;
				}
			}
			  run1.close();




import com.microfocus.cobol.runtime.RunUnit;
import java.sql.Connection;
import java.sql.SQLException;

public class RunUnitMonitor {
    public static void main(String[] args) {
        RunUnit run1 = new RunUnit();
        System.out.println("RunUnit Created: " + run1);  // Print RunUnit reference

        Runtime runtime = Runtime.getRuntime();
        long memoryBefore = runtime.totalMemory() - runtime.freeMemory();
        System.out.println("Memory Before RunUnit Execution: " + memoryBefore + " bytes");

        try (Connection connection = datasource.getConnection()) {
            System.out.println("Database connection established.");

            // Add the COBOL program to the RunUnit
            run1.Add(jvm60457);
            System.out.println("COBOL program added to RunUnit.");

            // Call the COBOL program
            run1.Call("JVM60457", 
                      cif_number.get_Reference(), 
                      opt_flag.get_Reference(), 
                      branch_num.get_Reference(), 
                      teller_num.get_Reference(), 
                      out_cif_details.get_Reference(), 
                      out_account_array.get_Reference(),  
                      out_error_num.get_Reference(), 
                      Rec_Area.get_Reference(), 
                      connection);
            System.out.println("COBOL program executed.");

            errno = out_error_num.getJvmOutErrorNo();
        } catch (SQLException e) {
            errno = "3293";
            System.out.println("SQL Exception occurred: " + e.getMessage());
        }

        // Processing output details
        cif_details = out_cif_details.getJvmOutCifDetails();
        index = 0;
        while (index <= 9999) {
            String account_details = out_account_array.getJvmOutput60457Output(index);
            if (!account_details.trim().isEmpty()) {
                Output_Acc = Output_Acc + account_details;
                index += 1;
            } else {
                break;
            }
        }

        // Closing RunUnit
        run1.close();
        System.out.println("RunUnit closed successfully.");

        // Suggest garbage collection
        run1 = null;
        System.gc();
        System.runFinalization();

        // Check memory after RunUnit execution
        long memoryAfter = runtime.totalMemory() - runtime.freeMemory();
        System.out.println("Memory After RunUnit Execution: " + memoryAfter + " bytes");

        if (memoryAfter > memoryBefore) {
            System.out.println("⚠️ Possible Memory Leak Detected!");
        } else {
            System.out.println("✅ Memory Released Successfully.");
        }
    }
}






import com.microfocus.cobol.runtime.RunUnit;
import java.lang.ref.PhantomReference;
import java.lang.ref.ReferenceQueue;
import java.sql.Connection;
import java.sql.SQLException;

public class RunUnitMonitor {
    private static ReferenceQueue<RunUnit> refQueue = new ReferenceQueue<>();

    static class RunUnitCleaner extends PhantomReference<RunUnit> {
        public RunUnitCleaner(RunUnit run1) {
            super(run1, refQueue);
        }

        public void cleanUp() {
            System.out.println("RunUnit is no longer referenced. Cleaning up...");
        }
    }

    public static void main(String[] args) {
        RunUnit run1 = new RunUnit();
        RunUnitCleaner cleaner = new RunUnitCleaner(run1);
        System.out.println("RunUnit Created: " + run1);

        long memoryBefore = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
        System.out.println("Memory Before Execution: " + memoryBefore + " bytes");

        try (Connection connection = datasource.getConnection()) {
            System.out.println("Database connection established.");
            run1.Add(jvm60457);
            run1.Call("JVM60457", 
                      cif_number.get_Reference(), 
                      opt_flag.get_Reference(), 
                      branch_num.get_Reference(), 
                      teller_num.get_Reference(), 
                      out_cif_details.get_Reference(), 
                      out_account_array.get_Reference(),  
                      out_error_num.get_Reference(), 
                      Rec_Area.get_Reference(), 
                      connection);
            System.out.println("COBOL program executed.");
        } catch (SQLException e) {
            System.out.println("SQL Exception: " + e.getMessage());
        }

        // Close RunUnit explicitly
        run1.close();
        System.out.println("RunUnit closed successfully.");

        // Nullify the reference and let the PhantomReference handle cleanup
        run1 = null;

        // Monitor memory after execution
        long memoryAfter = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
        System.out.println("Memory After Execution: " + memoryAfter + " bytes");

        // Check for cleanup
        if (refQueue.poll() != null) {
            cleaner.cleanUp();
        }

        if (memoryAfter < memoryBefore) {
            System.out.println("✅ Memory released successfully.");
        } else {
            System.out.println("⚠️ Possible memory leak detected!");
        }
    }
}





public class YONO_Child {
	
	Logger logger = LoggerFactory.getLogger(YONO_Child.class);
	   Connection connection;

	public List<String> callYONOEnquiryChild(String branch_number,  String tellerno, String cifno, String option_flag, DataSource datasource, String commonArea) throws InterruptedException, ExecutionException {
		int index;
		String Output_Acc = "";
		String cif_details;
		String errno;
		   JVM60457 jvm60457 = new JVM60457();
		
		logger.info("VC------------------------YONO Enquiry Child Service Started------------------------VC");
		
		JvmIn60457CifNo     cif_number        = new JvmIn60457CifNo();
		JvmIn60457OptnFlag  opt_flag          = new JvmIn60457OptnFlag();
		JvmInBranchNo       branch_num        = new JvmInBranchNo();
		JvmInTellerNo       teller_num        = new JvmInTellerNo();
		LsRecordArea 		Rec_Area          = new LsRecordArea();
		JvmOutCifDetails    out_cif_details   = new JvmOutCifDetails();
		JvmArrayOutputOut   out_account_array = new JvmArrayOutputOut();
		JvmOutErrorNo       out_error_num     = new JvmOutErrorNo();
         

		
		teller_num.setJvmInTellerNo(String.format("%016d", new BigInteger(tellerno)));
		cif_number.setJvmIn60457CifNo(String.format("%017d", new BigInteger(cifno)));
		opt_flag.setJvmIn60457OptnFlag(option_flag);
		branch_num.setJvmInBranchNo(branch_number);
		Rec_Area.setLsRecordArea(commonArea);
		 RunUnit run1 = new RunUnit();
		
		 System.out.println("RunUnit Created: " + run1);  // Print RunUnit reference

	        Runtime runtime = Runtime.getRuntime();
	        long memoryBefore = runtime.totalMemory() - runtime.freeMemory();
	        System.out.println("Memory Before RunUnit Execution: " + memoryBefore + " bytes");
	       
		 try (Connection connection = datasource.getConnection()){
			
	            run1.Add(jvm60457);
	         
	            System.out.println("COBOL program added to RunUnit.");
	           
 	    		run1.Call("JVM60457", cif_number.get_Reference(), opt_flag.get_Reference(), branch_num.get_Reference(), teller_num.get_Reference(), out_cif_details.get_Reference(), out_account_array.get_Reference(),  out_error_num.get_Reference(), Rec_Area.get_Reference(),connection);
 	    		errno = out_error_num.getJvmOutErrorNo();
		 } catch (SQLException e) {
	     errno = "VC010";
			 errno = "3293";

		}
		 
			 cif_details = out_cif_details.getJvmOutCifDetails();
			index = 0;
			while (index <= 9999) {
				String account_details = out_account_array.getJvmOutput60457Output(index);
				if (!account_details.trim().isEmpty()) {
					Output_Acc = Output_Acc + account_details;
					index+=1;
				}
				else {
					break;
				}
			}
			  run1.close();
			  System.out.println("RunUnit closed successfully.");
		        run1 = null;
		        long memoryAfter = runtime.totalMemory() - runtime.freeMemory();
		        System.out.println("Memory After RunUnit Execution: " + memoryAfter + " bytes");

		        if (memoryAfter > memoryBefore) {
		            System.out.println("Possible Memory Leak Detected");
		        } else {
		            System.out.println(" Memory Released Successfully.");
		        }
		    
			List<String> res = new ArrayList<>();
			res.add(cif_details);
			if (!Output_Acc.isEmpty()) {
				res.add(Output_Acc.substring(0, Output_Acc.length() - 317));
			}
			else {
				res.add(Output_Acc);
			}
			
			res.add(String.valueOf(index-1));
			res.add(errno);
			
			return res;
	}
	}




-----------------------------------


public class YONO_Child {
	
	Logger logger = LoggerFactory.getLogger(YONO_Child.class);
	   Connection connection;

	public List<String> callYONOEnquiryChild(String branch_number,  String tellerno, String cifno, String option_flag, DataSource datasource, String commonArea) throws InterruptedException, ExecutionException {
		int index;
		String Output_Acc = "";
		String cif_details;
		String errno;
		   JVM60457 jvm60457 = new JVM60457();
		
		logger.info("VC------------------------YONO Enquiry Child Service Started------------------------VC");
		
		JvmIn60457CifNo     cif_number        = new JvmIn60457CifNo();
		JvmIn60457OptnFlag  opt_flag          = new JvmIn60457OptnFlag();
		JvmInBranchNo       branch_num        = new JvmInBranchNo();
		JvmInTellerNo       teller_num        = new JvmInTellerNo();
		LsRecordArea 		Rec_Area          = new LsRecordArea();
		JvmOutCifDetails    out_cif_details   = new JvmOutCifDetails();
		JvmArrayOutputOut   out_account_array = new JvmArrayOutputOut();
		JvmOutErrorNo       out_error_num     = new JvmOutErrorNo();
         

		
		teller_num.setJvmInTellerNo(String.format("%016d", new BigInteger(tellerno)));
		cif_number.setJvmIn60457CifNo(String.format("%017d", new BigInteger(cifno)));
		opt_flag.setJvmIn60457OptnFlag(option_flag);
		branch_num.setJvmInBranchNo(branch_number);
		Rec_Area.setLsRecordArea(commonArea);
		 RunUnit run1 = new RunUnit();
		 RunUnit run2 = new RunUnit();
		 System.out.println("RunUnit Created: " + run1);  // Print RunUnit reference
		
        Runtime runtime = Runtime.getRuntime();
	        long memoryBefore = runtime.totalMemory() - runtime.freeMemory();
	        System.out.println("Memory Before RunUnit Execution: " + memoryBefore + " bytes");
	        //Changed
		 try (Connection connection = datasource.getConnection()){
			
	            run1.Add(jvm60457);
	            //Changed
	            System.out.println("COBOL program added to RunUnit.");
	            //Changed
 	    		run1.Call("JVM60457", cif_number.get_Reference(), opt_flag.get_Reference(), branch_num.get_Reference(), teller_num.get_Reference(), out_cif_details.get_Reference(), out_account_array.get_Reference(),  out_error_num.get_Reference(), Rec_Area.get_Reference(),connection);
 	    		errno = out_error_num.getJvmOutErrorNo();
		 } catch (SQLException e) {
			 errno = "3293";
		}
		 
			 cif_details = out_cif_details.getJvmOutCifDetails();
			index = 0;
			while (index <= 9999) {
				String account_details = out_account_array.getJvmOutput60457Output(index);
				if (!account_details.trim().isEmpty()) {
					Output_Acc = Output_Acc + account_details;
					index+=1;
				}
				else {
					break;
				}
			}
			  run1.close();
			  System.out.println("RunUnit closed successfully.");
		      run1=run2;	       
		        long memoryAfter = runtime.totalMemory() - runtime.freeMemory();
		        System.out.println("Memory After Execution: " + memoryAfter + " bytes");

		        if (memoryAfter > memoryBefore) {
		            System.out.println("Possible Memory Leak Detected");
		        } else {
		            System.out.println("Memory Released Successfully.");
		        }
		    
			List<String> res = new ArrayList<>();
			res.add(cif_details);
			if (!Output_Acc.isEmpty()) {
				res.add(Output_Acc.substring(0, Output_Acc.length() - 317));
			}
			else {
				res.add(Output_Acc);
			}
			
			res.add(String.valueOf(index-1));
			res.add(errno);
			
			return res;
	}
	}








=============================================================================================================

package com.tcs.bancs.microservices.util;

import com.tcs.bancs.microservices.config.CBSDayDbConfig;
import com.tcs.bancs.microservices.config.CacheConfig;
import com.tcs.bancs.microservices.db.model.Sysc;
import com.tcs.bancs.microservices.domain.DBData;
import com.tcs.bancs.microservices.exception.RuleAccessTechnicalException;
import com.tcs.bancs.microservices.interceptor.AggregatorRequestHandlerInterceptor;
import com.tcs.bancs.microservices.repository.night.SyscRepository;
import java.io.IOException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;
import javax.servlet.http.HttpServletRequest;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.Import;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;














@Service
@Import({CacheConfig.class})
public class DBProcess
{
@Autowired(required = false)
SyscRepository SyscRepository;
public static long dbStartTimeMillis;
@Autowired
ApplicationContext context;
@Autowired
HttpServletRequest HttpServletRequest;
@Autowired
DaoUtilities daoUtil;
public Integer[] pageDetails = new Integer[2];
public static Integer[] recordNumParam = new Integer[2];

Logger logger = LoggerFactory.getLogger(DBProcess.class);






public static final int defaultRowNumber = 10;







public DBData readSyscTable() {
DBData dbData = new DBData();
Sysc oSysc = new Sysc();

oSysc = this.SyscRepository.FetchSyscDetails(AggregatorConfigLoader.syscProperties.getProperty("TargetLevel"), AggregatorConfigLoader.syscProperties
.getProperty("RegionNo"), AggregatorConfigLoader.syscProperties
.getProperty("EntityNo"), AggregatorConfigLoader.syscProperties
.getProperty("SystemNo"), AggregatorConfigLoader.syscProperties
.getProperty("NodeNo"), AggregatorConfigLoader.syscProperties
.getProperty("ReplicaTypeX"), AggregatorConfigLoader.syscProperties
.getProperty("ReplicaNo"));
dbData.setAPP(oSysc.getSyscVariable().substring(10, 11));

dbData.setMASTER_1(oSysc.getSyscVariable().substring(37, 45).trim());
dbData.setMASTER_2(oSysc.getSyscVariable().substring(52, 60).trim());
dbData.setIN_USE(oSysc.getSyscVariable().substring(67, 75).trim());
return dbData;
}










public DBData fetchDbRegionDetails(String beanName, DBData dbData) throws Exception {
String type = "0";

if (dbData.getAPP().equals("D")) {

dbData.setDBINDICATOR("DD");
dbData.setACCESS_TYPE(type);
} else {
type = AggregatorConfigLoader.propertiesConfiguration.getProperty(beanName.toUpperCase());



String DBIndicator = dbData.getIN_USE().equals(CBSDayDbConfig.connectionType.trim()) ? "DN" : "RN";


dbData.setDBINDICATOR(DBIndicator);
dbData.setACCESS_TYPE(type);
} 
return dbData;
}




























public <T> T fetchRepositories(Object dbModelBean, String repoBeanName, String repositoryName, String repoMethod, boolean pagination, boolean isList, ArrayList<Object> queryParams) throws Exception {
T nightData = null;



try {
DBData dbData = new DBData();
dbData.setDBINDICATOR("DD");
dbData.setACCESS_TYPE("0");







if (pagination)
getPageDetails(); 
if (isList) {
getRowNumber();
}
if (AggregatorConfigLoader.applicationDBRregionType.equals("24")) {

dbData = (DBData)this.HttpServletRequest.getAttribute("DBData");

dbData = fetchDbRegionDetails(repoBeanName, dbData);
} 


String repositoryDDName = StringUtils.uncapitalize(RepoImplMapping2RepositoryBean("DD", repositoryName));


if (!"DD".equals(dbData.getDBINDICATOR())) {



String repositoryNight = StringUtils.uncapitalize(
RepoImplMapping2RepositoryBean("DN", repositoryName));












nightData = invokeRepository(dbModelBean, repositoryNight, repoMethod, queryParams, this.pageDetails[0], this.pageDetails[1], recordNumParam[0], pagination, isList);











if (nightData != null && dbData
.getACCESS_TYPE().equalsIgnoreCase("3")) {
return nightData;
}


if ("RN".equals(dbData.getDBINDICATOR())) {

String repositoryRef = StringUtils.uncapitalize(
RepoImplMapping2RepositoryBean("RN", repositoryName));
if (isList || pagination) {
return invokeListRepository(nightData, dbModelBean, repositoryRef, repoMethod, pagination, queryParams);
}
if (nightData == null) {
return invokeRepository(dbModelBean, repositoryRef, repoMethod, queryParams, this.pageDetails[0], this.pageDetails[1], recordNumParam[0], pagination, isList);
}
} 





if (isList || pagination) {
return invokeListRepository(nightData, dbModelBean, repositoryDDName, repoMethod, pagination, queryParams);
}
} 

















if (nightData == null) {
return invokeRepository(dbModelBean, repositoryDDName, repoMethod, queryParams, this.pageDetails[0], this.pageDetails[1], recordNumParam[0], pagination, isList);

}
}
catch (Exception e) {
throw e;
} 





return nightData;
}












































public <T> T invokeListRepository(T data, Object dbModelBean, String repositoryName, String repoMethod, boolean pagination, ArrayList<Object> queryParams) throws Exception {
Integer count = null;
List<T> list2 = new ArrayList<>();

if (pagination) {
Page<T> pagedResult = (Page<T>)data;

List<T> list3 = pagedResult.getContent();

if (this.pageDetails[1] != null && list3.size() != this.pageDetails[1].intValue()) {

count = (Integer)this.daoUtil.<T>calculatePageSize(list3, this.pageDetails[1].intValue());
if (count.intValue() != 0) {
queryParams.remove(queryParams.size() - 1);

Page<T> pagedResult2 = invokeRepository(dbModelBean, repositoryName, repoMethod, queryParams, this.pageDetails[0], count, null, pagination, false);


list2 = pagedResult2.getContent();
} 
} 








List<T> list4 = this.daoUtil.union(list3, list2);
return (T)new PageImpl(list4);
} 


List<T> list1 = (List<T>)data;

if (list1.size() == 0)
{
return invokeRepository(dbModelBean, repositoryName, repoMethod, queryParams, this.pageDetails[0], this.pageDetails[1], recordNumParam[0], pagination, true);
}




int listSize = 0;
boolean isRange = false;
if (recordNumParam.length == 2 && recordNumParam[1] != null) {
listSize = recordNumParam[1].intValue() - recordNumParam[0].intValue();
isRange = true;
} 

if (list1.size() != listSize) {
count = (Integer)this.daoUtil.<T>calculatePageSize(list1, listSize);
if (count.intValue() != 0) {

queryParams.remove(queryParams.size() - 1);

T data2 = invokeRepository(dbModelBean, repositoryName, repoMethod, queryParams, null, null, count, pagination, true);

list2 = (List<T>)data2;
} 
} 





List<T> returnObjList = this.daoUtil.union(list1, list2);
return (T)returnObjList;
}





public Integer[] getPageDetails() {
if (AggregatorRequestHandlerInterceptor.requestParamMap != null) {

int pageNumber = 0;

if ((AggregatorRequestHandlerInterceptor.requestParamMap.containsKey("page") && (AggregatorRequestHandlerInterceptor.requestParamMap
.containsKey("pageSize") || AggregatorRequestHandlerInterceptor.requestParamMap

.containsKey("page-size"))) || (this.HttpServletRequest
.getAttribute("page") != null && this.HttpServletRequest
.getAttribute("pageSize") != null)) {

if (this.HttpServletRequest.getParameter("page") == null) {


pageNumber = ((Integer)this.HttpServletRequest.getAttribute("page") == null) ? pageNumber : ((Integer)this.HttpServletRequest.getAttribute("page")).intValue();
} else {
pageNumber = Integer.valueOf(this.HttpServletRequest.getParameter("page")).intValue();
} 
if (pageNumber != 0)
pageNumber--; 
this.pageDetails[0] = Integer.valueOf(pageNumber);
if (this.HttpServletRequest.getParameter("pageSize") == null && this.HttpServletRequest
.getParameter("page-size") == null) {
this.pageDetails[1] = ((Integer)this.HttpServletRequest.getAttribute("pageSize") == null) ? null : (Integer)this.HttpServletRequest

.getAttribute("pageSize");
}
else if (this.HttpServletRequest.getParameter("pageSize") != null) {
this.pageDetails[1] = Integer.valueOf(this.HttpServletRequest.getParameter("pageSize"));
} else if (this.HttpServletRequest.getParameter("page-size") != null) {
this.pageDetails[1] = Integer.valueOf(this.HttpServletRequest.getParameter("page-size"));
} 
} 
} 








return this.pageDetails;
}






public Integer[] getRowNumber() {
if (AggregatorRequestHandlerInterceptor.requestParamMap.containsKey("recordNum") || this.HttpServletRequest
.getAttribute("recordNum") != null) {

recordNumParam[0] = Integer.valueOf((AggregatorRequestHandlerInterceptor.requestParamMap.get("recordNum") == null) ? (
(this.HttpServletRequest.getAttribute("recordNum") == null) ? 0 : ((Integer)this.HttpServletRequest
.getAttribute("recordNum")).intValue()) : ((Integer)AggregatorRequestHandlerInterceptor.requestParamMap
.get("recordNum")).intValue());

}
else if ((AggregatorRequestHandlerInterceptor.requestParamMap.containsKey("startRecordNum") || this.HttpServletRequest
.getAttribute("startRecordNum") != null) && (AggregatorRequestHandlerInterceptor.requestParamMap
.containsKey("endRecordNum") || this.HttpServletRequest
.getAttribute("endRecordNum") != null)) {

recordNumParam[0] = Integer.valueOf(
(AggregatorRequestHandlerInterceptor.requestParamMap.get("startRecordNum") == null) ? (
(this.HttpServletRequest.getAttribute("startRecordNum") == null) ? 0 : ((Integer)this.HttpServletRequest

.getAttribute("startRecordNum")).intValue()) : ((Integer)AggregatorRequestHandlerInterceptor.requestParamMap
.get("startRecordNum")).intValue());
recordNumParam[1] = Integer.valueOf((AggregatorRequestHandlerInterceptor.requestParamMap.get("endRecordNum") == null) ? (
(this.HttpServletRequest.getAttribute("endRecordNum") == null) ? 0 : ((Integer)this.HttpServletRequest
.getAttribute("endRecordNum")).intValue()) : ((Integer)AggregatorRequestHandlerInterceptor.requestParamMap
.get("endRecordNum")).intValue());
}
else {

recordNumParam[0] = Integer.valueOf(0);
} 

return recordNumParam;
}







public <T> T invokeRepository(Object dbModelBean, String repositoryName, String repoMethod, ArrayList<Object> queryParams, Integer page, Integer pageSize, Integer recordNum, boolean isPagination, boolean isList) throws Exception {
T t = null;
if (dbModelBean != null) {

Object inputData = null;
Class[] cArg = new Class[1];

if (dbModelBean != null) {
inputData = dbModelBean;
}
cArg[0] = inputData.getClass();

t = (T)this.context.getBean(repositoryName).getClass().getDeclaredMethod(repoMethod, cArg).invoke(this.context.getBean(repositoryName), new Object[] { inputData });


}
else if (queryParams != null) {

if (isPagination) {
if (page == null && pageSize == null) {
queryParams.add(null);
} else {

PageRequest pageRequest = PageRequest.of(page.intValue(), pageSize.intValue());
queryParams.add(pageRequest);
} 
}


if (isList && recordNum.intValue() != 0) {
queryParams.add(recordNum);
}
Class[] cArg = new Class[queryParams.size()];
Object[] data = new Object[queryParams.size()];
Object[] inputData = new Object[queryParams.size()];
for (int i = 0; i < queryParams.size(); i++) {


if (isPagination && queryParams.get(i) != null && queryParams.get(i).getClass() == PageRequest.class) {
cArg[cArg.length - 1] = Pageable.class;

}
else if (queryParams.get(i) == null) {
cArg[i] = String.class;
} else {
cArg[i] = queryParams.get(i).getClass();
} 
data[i] = queryParams.get(i);


inputData[i] = queryParams.get(i);
} 


t = (T)this.context.getBean(repositoryName).getClass().getDeclaredMethod(repoMethod, cArg).invoke(this.context.getBean(repositoryName), inputData);

}
else {

t = (T)this.context.getBean(repositoryName).getClass().getDeclaredMethod(repoMethod, new Class[0]).invoke(this.context.getBean(repositoryName), new Object[0]);
} 






return t;
}




public <T> T fetchRepository(Object dbModelBean, String repoBeanName, String repositoryName, String repoMethod, Object rowNum, boolean isList, ArrayList<Object> queryParams) throws Exception {
try {
long dbStartTimeMillis = System.currentTimeMillis();


Object returnObjData = null;

DBData dbData = new DBData();
dbData.setDBINDICATOR("DD");
dbData.setACCESS_TYPE("0");

if (AggregatorConfigLoader.applicationDBRregionType.equals("24")) {

dbData = (DBData)this.HttpServletRequest.getAttribute("DBData");

dbData = fetchDbRegionDetails(repoBeanName, dbData);
} 

String DBIndicator = dbData.getDBINDICATOR();

String primaryRepositoryName = RepoImplMapping2RepositoryClass(DBIndicator, repositoryName);

String secondRepositoryName = "";
Class<?> secondaryRepoClass = null;

Method secondaryRepoImplMethod = null;
boolean isSecondaryRepo = false;
if (!"DD".equals(dbData.getDBINDICATOR())) {
isSecondaryRepo = true;

if ("DN".equals(dbData.getDBINDICATOR())) {
secondRepositoryName = RepoImplMapping2RepositoryClass("DD", repositoryName);
}
else {

secondRepositoryName = primaryRepositoryName;
primaryRepositoryName = RepoImplMapping2RepositoryClass("RN", repositoryName);
} 
} 



Class<?> primaryRepoClass = Class.forName(primaryRepositoryName);

if (isSecondaryRepo) {
secondaryRepoClass = Class.forName(secondRepositoryName);
}



if (dbModelBean != null || rowNum != null) {





Object inputData = rowNum;

Class[] cArg = new Class[1];

if (dbModelBean != null) {
inputData = dbModelBean;
}
cArg[0] = inputData.getClass();
Method primaryRepoImplMethod = primaryRepoClass.getDeclaredMethod(repoMethod, cArg);

if (isSecondaryRepo) {
secondaryRepoImplMethod = secondaryRepoClass.getDeclaredMethod(repoMethod, cArg);
}








returnObjData = invokeRepositoryMethods(dbData, primaryRepoClass, secondaryRepoClass, primaryRepoImplMethod, secondaryRepoImplMethod, repoMethod, isList, rowNum, inputData, null);



}
else if (queryParams != null) {
Class[] cArg = new Class[queryParams.size()];
Object[] data = new Object[queryParams.size()];
Object[] inputData = new Object[queryParams.size()];
for (int i = 0; i < queryParams.size(); i++) {

cArg[i] = queryParams.get(i).getClass();
data[i] = queryParams.get(i);

inputData[i] = queryParams.get(i);
} 
Method primaryRepoImplMethod = primaryRepoClass.getDeclaredMethod(repoMethod, cArg);

if (isSecondaryRepo) {
secondaryRepoImplMethod = secondaryRepoClass.getDeclaredMethod(repoMethod, cArg);
}


returnObjData = invokeRepositoryMethods(dbData, primaryRepoClass, secondaryRepoClass, primaryRepoImplMethod, secondaryRepoImplMethod, repoMethod, isList, rowNum, null, inputData);


}
else {


Method primaryRepoImplMethod = primaryRepoClass.getDeclaredMethod(repoMethod, new Class[0]);
if (isSecondaryRepo) {
secondaryRepoImplMethod = secondaryRepoClass.getDeclaredMethod(repoMethod, new Class[0]);
}


returnObjData = invokeRepositoryMethods(dbData, primaryRepoClass, secondaryRepoClass, primaryRepoImplMethod, secondaryRepoImplMethod, repoMethod, isList, rowNum, null, null);
} 






return (T)returnObjData;
}
catch (Exception e) {


throw e;
} 
}
























public <T> T invokeRepositoryMethods(DBData dbData, Class primaryRepoClass, Class secondaryRepoClass, Method primaryRepoImplMethod, Method secondaryRepoImplMethod, String repoMethod, boolean isList, Object rowNum, Object inputData, Object[] inputDataArr) throws Exception {
Object object1 = null;
Object returnObj = new Object();
List<Object> returnObjList = new ArrayList();
long startTime = System.currentTimeMillis();


try {
if (isList) {
if (inputData != null) {
returnObjList = (List<Object>)primaryRepoImplMethod.invoke(this.context.getBean(primaryRepoClass), new Object[] { inputData });
}
else if (inputDataArr != null) {

returnObjList = (List<Object>)primaryRepoImplMethod.invoke(this.context.getBean(primaryRepoClass), inputDataArr);
} else {

returnObjList = (List<Object>)primaryRepoImplMethod.invoke(this.context.getBean(primaryRepoClass), new Object[0]);
} 
object1 = returnObjList;

}
else if (inputData != null) {
object1 = primaryRepoImplMethod.invoke(this.context.getBean(primaryRepoClass), new Object[] { inputData });
} else if (inputDataArr != null) {

object1 = primaryRepoImplMethod.invoke(this.context.getBean(primaryRepoClass), inputDataArr);
} else {

object1 = primaryRepoImplMethod.invoke(this.context.getBean(primaryRepoClass), new Object[0]);
} 


if (dbData.getACCESS_TYPE().equals("1")) {
List<Object> list = null;

Integer count = Integer.valueOf(0);
int rowNumber = 0;

if (rowNum == null) {
rowNumber = 10;
} else {

rowNumber = Integer.parseInt(rowNum.toString());
} 
if (isList) {

if (returnObjList.size() != rowNumber) {
count = (Integer)this.daoUtil.<Object>calculatePageSize(returnObjList, rowNumber);
if (count.intValue() != 0) {
List<Object> secondaryList = new ArrayList();
Class[] cArg = new Class[1];
cArg[0] = count.getClass();

if (inputData != null) {

secondaryList = (List<Object>)secondaryRepoImplMethod.invoke(this.context.getBean(secondaryRepoClass), new Object[] { count });
} else if (inputDataArr != null) {

secondaryList = (List<Object>)secondaryRepoImplMethod.invoke(this.context.getBean(secondaryRepoClass), inputDataArr);
} else {

secondaryList = (List<Object>)secondaryRepoImplMethod.invoke(this.context.getBean(secondaryRepoClass), new Object[] { count });
} 
returnObjList = this.daoUtil.union(returnObjList, secondaryList);
} 
} 

list = returnObjList;


}
else if (list == null) {

if (inputData != null) {
Object object = secondaryRepoImplMethod.invoke(this.context.getBean(secondaryRepoClass), new Object[] { inputData });
} else if (inputDataArr != null) {

Object object = secondaryRepoImplMethod.invoke(this.context.getBean(secondaryRepoClass), inputDataArr);
} else {

object1 = secondaryRepoImplMethod.invoke(this.context.getBean(secondaryRepoClass), new Object[0]);
}

} 
} 
} catch (Exception e) {

this.logger.error("Error at LineNumber ==> DBPROCESS : EXCEPTION");

throw new Exception();
} 




return (T)object1;
}



public String RepoImplMapping2RepositoryClass(String dbIndicator, String repoName) throws RuleAccessTechnicalException, IOException {
String className = "";
if (dbIndicator.equals("DD")) {
className = "com.tcs.bancs.microservices.repository.day." + repoName + "DayRepo";
}
else if (dbIndicator.equals("DN")) {
className = "com.tcs.bancs.microservices.repository.night." + repoName + "NightRepo";
}
else if (dbIndicator.equals("RN")) {
className = "com.tcs.bancs.microservices.repository.ref." + repoName + "RefRepo";
} 

return className;
}


public String RepoImplMapping2RepositoryBean(String dbIndicator, String repoName) throws RuleAccessTechnicalException, IOException {
String className = "";
if (dbIndicator.equals("DD")) {
className = repoName + "DayRepo";
} else if (dbIndicator.equals("DN")) {
className = repoName + "NightRepo";
} else if (dbIndicator.equals("RN")) {
className = repoName + "RefRepo";
} 
return className;
}
}
 YBANCS   D                          w012band
	

